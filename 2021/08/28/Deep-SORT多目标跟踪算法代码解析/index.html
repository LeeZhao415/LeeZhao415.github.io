<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Deep SORT多目标跟踪算法代码解析 | 且听风吟，御剑于心！</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="LeeZhao,LeeZhao's Blog" />
  
  <meta name="description" content="文章目录   Deep SORT 多目标跟踪算法代码解析  1. MOT 主要步骤 2. SORT 3. Deep SORT 4. Deep SORT 代码解析  4.1 类图 4.2 核心模块   5. 流程解析 6. 总结       Deep SORT 多目标跟踪算法代码解析 Deep SORT 是多目标跟踪 (Multi-Object Tracking) 中常用到的一种算法，是一个 D">
<meta property="og:type" content="article">
<meta property="og:title" content="Deep SORT多目标跟踪算法代码解析">
<meta property="og:url" content="https://leezhao415.github.io/2021/08/28/Deep-SORT%E5%A4%9A%E7%9B%AE%E6%A0%87%E8%B7%9F%E8%B8%AA%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="且听风吟，御剑于心！">
<meta property="og:description" content="文章目录   Deep SORT 多目标跟踪算法代码解析  1. MOT 主要步骤 2. SORT 3. Deep SORT 4. Deep SORT 代码解析  4.1 类图 4.2 核心模块   5. 流程解析 6. 总结       Deep SORT 多目标跟踪算法代码解析 Deep SORT 是多目标跟踪 (Multi-Object Tracking) 中常用到的一种算法，是一个 D">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-5ee95ab63b94885033dc3672dd6a01ed_1440w.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-59c266eafbd67594518ea7993df404de_1440w.jpg">
<meta property="og:image" content="https://www.zhihu.com/equation?tex=T_%7Blost%7D">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-e3993a920cea6df12c56ac9603d4e7da_1440w.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-ad78b882e0a502e8459c2adf6792a7a3_1440w.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-8405e6e67486b852cea11037b6e66731_1440w.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-45488a95421c8f2862fcfb196f7610ac_1440w.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-e33924c236044a1a03d61392707fa3b3_1440w.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-a6bf49b08b32079b63d637c46beb6d45_1440w.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-cec3dfff80f4d4c8ccc34fb3636c1b6d_1440w.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-e3993a920cea6df12c56ac9603d4e7da_1440w.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-73da349ebf5c4b8e765798de8bad4be7_1440w.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-101b77477f3e96f762ac71029058f621_1440w.jpg">
<meta property="og:image" content="https://www.zhihu.com/equation?tex=x%27%3DFx+%5C%5C">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-c3548868fe9a0a32461752c33434dae8_1440w.jpg">
<meta property="og:image" content="https://www.zhihu.com/equation?tex=P%27%3DFPF%5ET%2BQ+%5C%5C">
<meta property="og:image" content="https://www.zhihu.com/equation?tex=y%3Dz-Hx%27+%5C%5C+%5C%5C">
<meta property="og:image" content="https://www.zhihu.com/equation?tex=S%3DHP%27H%5ET%2BR+%5C%5C+%5C%5C">
<meta property="og:image" content="https://www.zhihu.com/equation?tex=K%3DP%27H%5ETS%5E%7B-1%7D+%5C%5C+%5C%5C">
<meta property="og:image" content="https://www.zhihu.com/equation?tex=x%3Dx%27%2BKy+%5C%5C+%5C%5C">
<meta property="og:image" content="https://www.zhihu.com/equation?tex=P%3D%28I-KH%29P%27+%5C%5C">
<meta property="og:image" content="https://www.zhihu.com/equation?tex=y%3Dz-Hx%27+%5C%5C">
<meta property="og:image" content="https://www.zhihu.com/equation?tex=x%27">
<meta property="og:image" content="https://www.zhihu.com/equation?tex=S%3DHP%27H%5ET%2BR+%5C%5C">
<meta property="og:image" content="https://www.zhihu.com/equation?tex=K%3DP%27H%5ETS%5E%7B-1%7D+%5C%5C">
<meta property="og:image" content="https://www.zhihu.com/equation?tex=x%3Dx%27%2BKy+%5C%5C">
<meta property="og:image" content="https://www.zhihu.com/equation?tex=P%3D%28I-KH%29P%27+%5C%5C">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-baea18c4eceb6bbf810b8225d358defc_1440w.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-e3993a920cea6df12c56ac9603d4e7da_1440w.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-ad78b882e0a502e8459c2adf6792a7a3_1440w.jpg">
<meta property="article:published_time" content="2021-08-28T12:46:21.000Z">
<meta property="article:modified_time" content="2021-08-28T12:57:03.221Z">
<meta property="article:author" content="LeeZhao">
<meta property="article:tag" content="人工智能">
<meta property="article:tag" content="MOT">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic2.zhimg.com/80/v2-5ee95ab63b94885033dc3672dd6a01ed_1440w.jpg">
  
  
    <link rel="icon" href="/images/hatRSS blk.ico">
  
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
  
<link rel="stylesheet" href="/css/style.css">

  
<script src="/js/pace.min.js"></script>

  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'true', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


  
	<script>
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "//hm.baidu.com/hm.js?true";
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
	</script>

  
  <div style="display: none;">
    <script src="//s22.cnzz.com/z_stat.php?id=true&web_id=true" language="JavaScript"></script>
  </div>


<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
      <header id="header">
    <div id="banner"></div>
    <div id="header-outer">
        <div id="header-menu" class="header-menu-pos animated">
            <div class="header-menu-container">
                <a href="/" class="left">
                    <span class="site-title">LeeZhao&#39;s Blog</span>
                </a>
                <nav id="header-menu-nav" class="right">
                    
                    <a  href="/">
                        <i class="fa fa-home"></i>
                        <span>Home</span>
                    </a>
                    
                    <a  href="/archives">
                        <i class="fa fa-archive"></i>
                        <span>Archives</span>
                    </a>
                    
                    <a  href="/about">
                        <i class="fa fa-user"></i>
                        <span>About</span>
                    </a>
                    
                </nav>
                <a class="mobile-header-menu-button">
                    <i class="fa fa-bars"></i>
                </a>
            </div>
        </div>
        <div id="header-row">
            <div id="logo">
                <a href="/">
                    <img src="/images/logo.jpg" alt="logo">
                </a>
            </div>
            <div class="header-info">
                <div id="header-title">
                    
                    <h2>
                        LeeZhao&#39;s Blog
                    </h2>
                    
                </div>
                <div id="header-description">
                    
                    <h3>
                        且听风吟，御剑于心！
                    </h3>
                    
                </div>
            </div>
            <nav class="header-nav">
                <div class="social">
                    
                        <a title="CSDN" target="_blank" href="//blog.csdn.net/qq_36722887">
                            <i class="fa fa-home fa-2x"></i></a>
                    
                        <a title="Github" target="_blank" href="//github.com/leezhao415">
                            <i class="fa fa-github fa-2x"></i></a>
                    
                        <a title="Weibo" target="_blank" href="//weibo.com/u/5120617296/home?topnav=1&wvr=6">
                            <i class="fa fa-weibo fa-2x"></i></a>
                    
                        <a title="CodeSearch" target="_blank" href="//codesearch.aixcoder.com">
                            <i class="fa fa-twitter fa-2x"></i></a>
                    
                </div>
            </nav>
        </div>
    </div>
</header>
      <div class="outer">
        <section id="main" class="body-wrap"><article id="post-Deep-SORT多目标跟踪算法代码解析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="post-title" itemprop="name">
      Deep SORT多目标跟踪算法代码解析
    </h1>
    <div class="post-title-bar">
      <ul>
          
              <li>
                  <i class="fa fa-book"></i>
                  
                      <a href="/categories/Hot/">Hot</a>
                  
              </li>
          
        <li>
          <i class="fa fa-calendar"></i>  2021-08-28
        </li>
        <li>
          <i class="fa fa-eye"></i>
          <span id="busuanzi_value_page_pv"></span>
        </li>
      </ul>
    </div>
  

          
      </header>
    
    <div class="article-entry post-content" itemprop="articleBody">
      
            
            <meta name="referrer" content="no-referrer">
<hr>
<p><strong>文章目录</strong></p>
<!-- toc -->
<ul>
<li><a href="#deep-sort%E5%A4%9A%E7%9B%AE%E6%A0%87%E8%B7%9F%E8%B8%AA%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90">Deep SORT 多目标跟踪算法代码解析</a>
<ul>
<li><a href="#1-mot%E4%B8%BB%E8%A6%81%E6%AD%A5%E9%AA%A4">1. MOT 主要步骤</a></li>
<li><a href="#2-sort">2. SORT</a></li>
<li><a href="#3-deep-sort">3. Deep SORT</a></li>
<li><a href="#4-deep-sort%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90">4. Deep SORT 代码解析</a>
<ul>
<li><a href="#41-%E7%B1%BB%E5%9B%BE">4.1 类图</a></li>
<li><a href="#42-%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97">4.2 核心模块</a></li>
</ul>
</li>
<li><a href="#5-%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90">5. 流程解析</a></li>
<li><a href="#6-%E6%80%BB%E7%BB%93">6. 总结</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<hr>
<h3><span id="deep-sort-多目标跟踪算法代码解析"> Deep SORT 多目标跟踪算法代码解析</span></h3>
<p>Deep SORT 是多目标跟踪 (Multi-Object Tracking) 中常用到的一种算法，是一个 Detection Based Tracking 的方法。这个算法工业界关注度非常高，在知乎上有很多文章都是使用了 Deep SORT 进行工程部署。笔者将参考前辈的博客，结合自己的实践 (理论 &amp; 代码) 对 Deep SORT 算法进行代码层面的解析。</p>
<p>在之前笔者写的一篇<a href="https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3F__biz%3DMzA4MjY4NTk0NQ%3D%3D%26mid%3D2247485748%26idx%3D1%26sn%3Deb0344e1fd47e627e3349e1b0c1b8ada%26chksm%3D9f80b3a2a8f73ab4dd043a6947e66d0f95b2b913cdfcc620cfa5b995958efe1bb1ba23e60100%26scene%3D126%26sessionid%3D1587264986%26key%3D1392818bdbc0aa1829bb274560d74860b77843df4c0179a2cede3a831ed1c279c4603661ecb8b761c481eecb80e5232d46768e615d1e6c664b4b3ff741a8492de87f9fab89805974de8b13329daee020%26ascene%3D1%26uin%3DNTA4OTc5NTky%26devicetype%3DWindows%2B10%2Bx64%26version%3D62090069%26lang%3Dzh_CN%26exportkey%3DAeR8oQO0h9Dr%2FAVfL6g0VGE%3D%26pass_ticket%3DR0d5J%2BVWKbvqy93YqUC%2BtoKE9cFI22uY90G3JYLOU0LtrcYM2WzBJL2OxnAh0vLo"> Deep SORT 论文阅读总结</a>中，总结了 DeepSORT 论文中提到的核心观点，如果对 Deep SORT 不是很熟悉，可以先理解一下，然后再来看解读代码的部分。</p>
<p>由于知乎对文章篇幅有限制，所以分上下篇发。</p>
<p>上篇将梳理 SORT、Deep SORT，以类图为主，讲解 DeepSORT 代码部分的各个模块。</p>
<p>下篇主要是梳理运行的流程，对照流程图进行代码层面理解。以及最后的总结 + 代码推荐。</p>
<h4><span id="1-mot-主要步骤"> 1. MOT 主要步骤</span></h4>
<p>在《DEEP LEARNING IN VIDEO MULTI-OBJECT TRACKING: A SURVEY》这篇基于深度学习的多目标跟踪的综述中，描述了 MOT 问题中四个主要步骤：</p>
<center><img src="https://pic2.zhimg.com/80/v2-5ee95ab63b94885033dc3672dd6a01ed_1440w.jpg" alt="img" style="zoom: 67%;"></center>
<ul>
<li>给定视频原始帧。</li>
<li>运行目标检测器如 Faster R-CNN、YOLOv3、SSD 等进行检测，获取目标检测框。</li>
<li>将所有目标框中对应的目标抠出来，进行特征提取（包括表观特征或者运动特征）。</li>
<li>进行相似度计算，计算前后两帧目标之间的匹配程度（前后属于同一个目标的之间的距离比较小，不同目标的距离比较大）</li>
<li>数据关联，为每个对象分配目标的 ID。</li>
</ul>
<p>以上就是四个核心步骤，其中核心是检测，SORT 论文的摘要中提到，仅仅换一个更好的检测器，就可以将目标跟踪表现提升 18.9%。</p>
<h4><span id="2-sort"> 2. SORT</span></h4>
<p>Deep SORT 算法的前身是 SORT, 全称是 Simple Online and Realtime Tracking。简单介绍一下，SORT 最大特点是基于 Faster R-CNN 的目标检测方法，并利用卡尔曼滤波算法 + 匈牙利算法，极大提高了多目标跟踪的速度，同时达到了 SOTA 的准确率。</p>
<p>这个算法确实是在实际应用中使用较为广泛的一个算法，核心就是两个算法：<strong>卡尔曼滤波</strong>和<strong>匈牙利算法</strong>。</p>
<p><strong>卡尔曼滤波算法</strong>分为两个过程，预测和更新。该算法将目标的运动状态定义为 8 个正态分布的向量。</p>
<p>预测：当目标经过移动，通过上一帧的目标框和速度等参数，预测出当前帧的目标框位置和速度等参数。</p>
<p>更新：预测值和观测值，两个正态分布的状态进行线性加权，得到目前系统预测的状态。</p>
<p><strong>匈牙利算法</strong>：解决的是一个分配问题，在 MOT 主要步骤中的计算相似度的，得到了前后两帧的相似度矩阵。匈牙利算法就是通过求解这个相似度矩阵，从而解决前后两帧真正匹配的目标。这部分 sklearn 库有对应的函数 linear_assignment 来进行求解。</p>
<p><strong>SORT 算法</strong>中是通过前后两帧 IOU 来构建相似度矩阵，所以 SORT 计算速度非常快。</p>
<p>下图是一张 SORT 核心算法流程图：</p>
<center><img src="https://pic3.zhimg.com/80/v2-59c266eafbd67594518ea7993df404de_1440w.jpg" alt="img" style="zoom:80%;"></center>
<p><strong>Detections</strong> 是通过目标检测器得到的目标框，<strong>Tracks</strong> 是一段轨迹。核心是匹配的过程与卡尔曼滤波的预测和更新过程。</p>
<p><strong>流程如下</strong>：目标检测器得到目标框 Detections，同时卡尔曼滤波器预测当前的帧的 Tracks, 然后将 Detections 和 Tracks 进行 IOU 匹配，最终得到的结果分为：</p>
<ul>
<li>Unmatched Tracks，这部分被认为是失配，Detection 和 Track 无法匹配，如果失配持续了<img src="https://www.zhihu.com/equation?tex=T_%7Blost%7D" alt="[公式]"> 次，该目标 ID 将从图片中删除。</li>
<li>Unmatched Detections, 这部分说明没有任意一个 Track 能匹配 Detection, 所以要为这个 detection 分配一个新的 track。</li>
<li>Matched Track，这部分说明得到了匹配。</li>
</ul>
<p>卡尔曼滤波可以根据 Tracks 状态<strong>预测</strong>下一帧的目标框状态。</p>
<p>卡尔曼滤波<strong>更新</strong>是对观测值 (匹配上的 Track) 和估计值更新所有 track 的状态。</p>
<h4><span id="3-deep-sort"> 3. Deep SORT</span></h4>
<p>DeepSort 中最大的特点是加入<strong>外观信息</strong>，借用了 ReID 领域模型来提取特征，减少了 ID switch 的次数。整体流程图如下：</p>
<center><img src="https://pic3.zhimg.com/80/v2-e3993a920cea6df12c56ac9603d4e7da_1440w.jpg" alt="img" style="zoom: 80%;"></center>
<p>可以看出，Deep SORT 算法在 SORT 算法的基础上增加了级联匹配 (Matching Cascade)+ 新轨迹的确认 (confirmed)。总体流程就是：</p>
<ul>
<li>卡尔曼滤波器预测轨迹 Tracks</li>
<li>使用匈牙利算法将预测得到的轨迹 Tracks 和当前帧中的 detections 进行匹配 (级联匹配和 IOU 匹配)</li>
<li>卡尔曼滤波更新。</li>
</ul>
<p>其中上图中的级联匹配展开如下：</p>
<center><img src="https://pic4.zhimg.com/80/v2-ad78b882e0a502e8459c2adf6792a7a3_1440w.jpg" alt="img" style="zoom:50%;"></center>
<p>上图非常清晰地解释了如何进行级联匹配，上图由虚线划分为两部分：</p>
<p>上半部分中计算相似度矩阵的方法使用到了<strong>外观模型</strong> (ReID) 和<strong>运动模型</strong> (马氏距离) 来计算相似度，得到代价矩阵，另外一个则是门控矩阵，用于限制代价矩阵中过大的值。</p>
<p>下半部分中是是<strong>级联匹配的数据关联</strong>步骤，匹配过程是一个循环 (max age 个迭代，默认为 70)，也就是从 missing age=0 到 missing age=70 的轨迹和 Detections 进行匹配，没有丢失过的轨迹优先匹配，丢失较为久远的就靠后匹配。通过这部分处理，可以重新将被遮挡目标找回，降低<strong>被遮挡然后再出现的目标</strong>发生的 ID Switch 次数。</p>
<p>将 Detection 和 Track 进行匹配，所以出现几种情况</p>
<ol>
<li>Detection 和 Track 匹配，也就是<strong> Matched Tracks</strong>。普通连续跟踪的目标都属于这种情况，前后两帧都有目标，能够匹配上。</li>
<li>Detection 没有找到匹配的 Track，也就是<strong> Unmatched Detections</strong>。图像中突然出现新的目标的时候，Detection 无法在之前的 Track 找到匹配的目标。</li>
<li>Track 没有找到匹配的 Detection，也就是<strong> Unmatched Tracks</strong>。连续追踪的目标超出图像区域，Track 无法与当前任意一个 Detection 匹配。</li>
<li>以上没有涉及一种特殊的情况，就是两个目标遮挡的情况。刚刚被遮挡的目标的 Track 也无法匹配 Detection，目标暂时从图像中消失。之后被遮挡目标再次出现的时候，应该尽量让被遮挡目标分配的 ID 不发生变动，减少 ID Switch 出现的次数，这就需要用到级联匹配了。</li>
</ol>
<h4><span id="4-deep-sort-代码解析"> 4. Deep SORT 代码解析</span></h4>
<p>论文中提供的代码是如下地址: <a href="https://link.zhihu.com/?target=https%3A//github.com/nwojke/deep_sort">https://github.com/nwojke/deep_sort</a></p>
<center><img src="https://pic2.zhimg.com/80/v2-8405e6e67486b852cea11037b6e66731_1440w.jpg" alt="img" style="zoom: 80%;"></center>
<p>上图是 Github 库中有关 Deep SORT 的核心代码，不包括 Faster R-CNN 检测部分，所以主要将讲解这部分的几个文件，笔者也对其中核心代码进行了部分注释，地址在: <a href="https://link.zhihu.com/?target=https%3A//github.com/pprp/deep_sort_yolov3_pytorch">https://github.com/pprp/deep_sort_yolov3_pytorch</a> , 将其中的目标检测器换成了 U 版的 yolov3, 将 deep_sort 文件中的核心进行了调用。</p>
<h5><span id="41-类图"> 4.1 类图</span></h5>
<p>下图是笔者总结的这几个类调用的类图 (不是特别严谨，但是能大概展示各个模块的关系)：</p>
<center><img src="https://pic1.zhimg.com/80/v2-45488a95421c8f2862fcfb196f7610ac_1440w.jpg" alt="img" style="zoom: 60%;"></center>
<p>DeepSort 是核心类，调用其他模块，大体上可以分为三个模块：</p>
<ul>
<li>ReID 模块，用于提取表观特征，原论文中是生成了 128 维的 embedding。</li>
<li>Track 模块，轨迹类，用于保存一个 Track 的状态信息，是一个基本单位。</li>
<li>Tracker 模块，Tracker 模块掌握最核心的算法，<strong>卡尔曼滤波</strong>和<strong>匈牙利算法</strong>都是通过调用这个模块来完成的。</li>
</ul>
<p>DeepSort 类对外接口非常简单：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.deepsort = DeepSort(args.deepsort_checkpoint)<span class="comment">#实例化</span></span><br><span class="line">outputs = self.deepsort.update(bbox_xcycwh, cls_conf, im)<span class="comment">#通过接收目标检测结果进行更新</span></span><br></pre></td></tr></table></figure>
<p>在外部调用的时候只需要以上两步即可，非常简单。</p>
<p>通过类图，对整体模块有了框架上理解，下面深入理解一下这些模块。</p>
<h5><span id="42-核心模块"> 4.2 核心模块</span></h5>
<h6><span id="detection-类"> Detection 类</span></h6>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Detection</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    This class represents a bounding box detection in a single image.</span></span><br><span class="line"><span class="string"> &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, tlwh, confidence, feature</span>):</span></span><br><span class="line">        self.tlwh = np.asarray(tlwh, dtype=np.<span class="built_in">float</span>)</span><br><span class="line">        self.confidence = <span class="built_in">float</span>(confidence)</span><br><span class="line">        self.feature = np.asarray(feature, dtype=np.float32)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_tlbr</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Convert bounding box to format `(min x, min y, max x, max y)`, i.e.,</span></span><br><span class="line"><span class="string">        `(top left, bottom right)`.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ret = self.tlwh.copy()</span><br><span class="line">        ret[<span class="number">2</span>:] += ret[:<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_xyah</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Convert bounding box to format `(center x, center y, aspect ratio,</span></span><br><span class="line"><span class="string">        height)`, where the aspect ratio is `width / height`.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ret = self.tlwh.copy()</span><br><span class="line">        ret[:<span class="number">2</span>] += ret[<span class="number">2</span>:] / <span class="number">2</span></span><br><span class="line">        ret[<span class="number">2</span>] /= ret[<span class="number">3</span>]</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
<p>Detection 类用于保存通过目标检测器得到的一个检测框，包含 top left 坐标 + 框的宽和高，以及该 bbox 的置信度还有通过 reid 获取得到的对应的 embedding。除此以外提供了不同 bbox 位置格式的转换方法：</p>
<ul>
<li>tlwh: 代表左上角坐标 + 宽高</li>
<li>tlbr: 代表左上角坐标 + 右下角坐标</li>
<li>xyah: 代表中心坐标 + 宽高比 + 高</li>
</ul>
<h6><span id="track-类"> Track 类</span></h6>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Track</span>:</span></span><br><span class="line">    <span class="comment"># 一个轨迹的信息，包含(x,y,a,h) &amp; v</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    A single target track with state space `(x, y, a, h)` and associated</span></span><br><span class="line"><span class="string">    velocities, where `(x, y)` is the center of the bounding box, `a` is the</span></span><br><span class="line"><span class="string">    aspect ratio and `h` is the height.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, mean, covariance, track_id, n_init, max_age,</span></span></span><br><span class="line"><span class="function"><span class="params">                 feature=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="comment"># max age是一个存活期限，默认为70帧,在</span></span><br><span class="line">        self.mean = mean</span><br><span class="line">        self.covariance = covariance</span><br><span class="line">        self.track_id = track_id</span><br><span class="line">        self.hits = <span class="number">1</span> </span><br><span class="line">        <span class="comment"># hits和n_init进行比较</span></span><br><span class="line">        <span class="comment"># hits每次update的时候进行一次更新（只有match的时候才进行update）</span></span><br><span class="line">        <span class="comment"># hits代表匹配上了多少次，匹配次数超过n_init就会设置为confirmed状态</span></span><br><span class="line">        self.age = <span class="number">1</span> <span class="comment"># 没有用到，和time_since_update功能重复</span></span><br><span class="line">        self.time_since_update = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 每次调用predict函数的时候就会+1</span></span><br><span class="line">        <span class="comment"># 每次调用update函数的时候就会设置为0</span></span><br><span class="line"></span><br><span class="line">        self.state = TrackState.Tentative</span><br><span class="line">        self.features = []</span><br><span class="line">        <span class="comment"># 每个track对应多个features, 每次更新都将最新的feature添加到列表中</span></span><br><span class="line">        <span class="keyword">if</span> feature <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.features.append(feature)</span><br><span class="line"></span><br><span class="line">        self._n_init = n_init  <span class="comment"># 如果连续n_init帧都没有出现失配，设置为deleted状态</span></span><br><span class="line">        self._max_age = max_age  <span class="comment"># 上限</span></span><br></pre></td></tr></table></figure>
<p>Track 类主要存储的是轨迹信息，mean 和 covariance 是保存的框的位置和速度信息，track_id 代表分配给这个轨迹的 ID。state 代表框的状态，有三种：</p>
<ul>
<li>Tentative: 不确定态，这种状态会在初始化一个 Track 的时候分配，并且只有在连续匹配上 n_init 帧才会转变为确定态。如果在处于不确定态的情况下没有匹配上任何 detection，那将转变为删除态。</li>
<li>Confirmed: 确定态，代表该 Track 确实处于匹配状态。如果当前 Track 属于确定态，但是失配连续达到 max age 次数的时候，就会被转变为删除态。</li>
<li>Deleted: 删除态，说明该 Track 已经失效。</li>
</ul>
<center><img src="https://pic4.zhimg.com/80/v2-e33924c236044a1a03d61392707fa3b3_1440w.jpg" alt="img" style="zoom: 67%;"></center>
<p><strong>max_age</strong> 代表一个 Track 存活期限，他需要和 time_since_update 变量进行比对。time_since_update 是每次轨迹调用 predict 函数的时候就会 + 1，每次调用 predict 的时候就会重置为 0，也就是说如果一个轨迹长时间没有 update (没有匹配上) 的时候，就会不断增加，直到 time_since_update 超过 max age (默认 70)，将这个 Track 从 Tracker 中的列表删除。</p>
<p><strong>hits</strong> 代表连续确认多少次，用在从不确定态转为确定态的时候。每次 Track 进行 update 的时候，hits 就会 + 1, 如果 hits&gt;n_init (默认为 3)，也就是连续三帧的该轨迹都得到了匹配，这时候才将不确定态转为确定态。</p>
<p>需要说明的是每个轨迹还有一个重要的变量，<strong>features</strong> 列表，存储该轨迹在不同帧对应位置通过 ReID 提取到的特征。为何要保存这个列表，而不是将其更新为当前最新的特征呢？这是为了解决目标被遮挡后再次出现的问题，需要从以往帧对应的特征进行匹配。另外，如果特征过多会严重拖慢计算速度，所以有一个参数<strong> budget</strong> 用来控制特征列表的长度，取最新的 budget 个 features, 将旧的删除掉。</p>
<h6><span id="reid-特征提取部分"> ReID 特征提取部分</span></h6>
<p>ReID 网络是独立于目标检测和跟踪器的模块，功能是提取对应 bounding box 中的 feature, 得到一个固定维度的 embedding 作为该 bbox 的代表，供计算相似度时使用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Extractor</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, model_name, model_path, use_cuda=<span class="literal">True</span></span>):</span></span><br><span class="line">        self.net = build_model(name=model_name,</span><br><span class="line">                               num_classes=<span class="number">96</span>)</span><br><span class="line">        self.device = <span class="string">&quot;cuda&quot;</span> <span class="keyword">if</span> torch.cuda.is_available(</span><br><span class="line">        ) <span class="keyword">and</span> use_cuda <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span></span><br><span class="line">        state_dict = torch.load(model_path)[<span class="string">&#x27;net_dict&#x27;</span>]</span><br><span class="line">        self.net.load_state_dict(state_dict)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Loading weights from &#123;&#125;... Done!&quot;</span>.<span class="built_in">format</span>(model_path))</span><br><span class="line">        self.net.to(self.device)</span><br><span class="line">        self.size = (<span class="number">128</span>,<span class="number">128</span>)</span><br><span class="line">        self.norm = transforms.Compose([</span><br><span class="line">            transforms.ToTensor(),</span><br><span class="line">            transforms.Normalize([<span class="number">0.3568</span>, <span class="number">0.3141</span>, <span class="number">0.2781</span>],</span><br><span class="line">                                 [<span class="number">0.1752</span>, <span class="number">0.1857</span>, <span class="number">0.1879</span>])</span><br><span class="line">        ])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_preprocess</span>(<span class="params">self, im_crops</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        TODO:</span></span><br><span class="line"><span class="string">            1. to float with scale from 0 to 1</span></span><br><span class="line"><span class="string">            2. resize to (64, 128) as Market1501 dataset did</span></span><br><span class="line"><span class="string">            3. concatenate to a numpy array</span></span><br><span class="line"><span class="string">            3. to torch Tensor</span></span><br><span class="line"><span class="string">            4. normalize</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">_resize</span>(<span class="params">im, size</span>):</span></span><br><span class="line">            <span class="keyword">return</span> cv2.resize(im.astype(np.float32) / <span class="number">255.</span>, size)</span><br><span class="line"></span><br><span class="line">        im_batch = torch.cat([</span><br><span class="line">            self.norm(_resize(im, self.size)).unsqueeze(<span class="number">0</span>) <span class="keyword">for</span> im <span class="keyword">in</span> im_crops</span><br><span class="line">        ],dim=<span class="number">0</span>).<span class="built_in">float</span>()</span><br><span class="line">        <span class="keyword">return</span> im_batch</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, im_crops</span>):</span></span><br><span class="line">        im_batch = self._preprocess(im_crops)</span><br><span class="line">        <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">            im_batch = im_batch.to(self.device)</span><br><span class="line">            features = self.net(im_batch)</span><br><span class="line">        <span class="keyword">return</span> features.cpu().numpy()</span><br></pre></td></tr></table></figure>
<p>模型训练是按照传统 ReID 的方法进行，使用 Extractor 类的时候输入为一个 list 的图片，得到图片对应的特征。</p>
<h6><span id="nearestneighbordistancemetric-类"> NearestNeighborDistanceMetric 类</span></h6>
<p>这个类中用到了两个计算距离的函数：</p>
<ol>
<li>计算欧氏距离</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_pdist</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="comment"># 用于计算成对的平方距离</span></span><br><span class="line">    <span class="comment"># a NxM 代表N个对象，每个对象有M个数值作为embedding进行比较</span></span><br><span class="line">    <span class="comment"># b LxM 代表L个对象，每个对象有M个数值作为embedding进行比较</span></span><br><span class="line">    <span class="comment"># 返回的是NxL的矩阵，比如dist[i][j]代表a[i]和b[j]之间的平方和距离</span></span><br><span class="line">    <span class="comment"># 实现见：https://blog.csdn.net/frankzd/article/details/80251042</span></span><br><span class="line">    a, b = np.asarray(a), np.asarray(b)  <span class="comment"># 拷贝一份数据</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(a) == <span class="number">0</span> <span class="keyword">or</span> <span class="built_in">len</span>(b) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> np.zeros((<span class="built_in">len</span>(a), <span class="built_in">len</span>(b)))</span><br><span class="line">    a2, b2 = np.square(a).<span class="built_in">sum</span>(axis=<span class="number">1</span>), np.square(</span><br><span class="line">        b).<span class="built_in">sum</span>(axis=<span class="number">1</span>)  <span class="comment"># 求每个embedding的平方和</span></span><br><span class="line">    <span class="comment"># sum(N) + sum(L) -2 x [NxM]x[MxL] = [NxL]</span></span><br><span class="line">    r2 = -<span class="number">2.</span> * np.dot(a, b.T) + a2[:, <span class="literal">None</span>] + b2[<span class="literal">None</span>, :]</span><br><span class="line">    r2 = np.clip(r2, <span class="number">0.</span>, <span class="built_in">float</span>(np.inf))</span><br><span class="line">    <span class="keyword">return</span> r2</span><br></pre></td></tr></table></figure>
<center><img src="https://pic2.zhimg.com/80/v2-a6bf49b08b32079b63d637c46beb6d45_1440w.jpg" alt="img" style="zoom: 67%;"></center>
<ol>
<li>计算余弦距离</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_cosine_distance</span>(<span class="params">a, b, data_is_normalized=<span class="literal">False</span></span>):</span></span><br><span class="line">    <span class="comment"># a和b之间的余弦距离</span></span><br><span class="line">    <span class="comment"># a : [NxM] b : [LxM]</span></span><br><span class="line">    <span class="comment"># 余弦距离 = 1 - 余弦相似度</span></span><br><span class="line">    <span class="comment"># https://blog.csdn.net/u013749540/article/details/51813922</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> data_is_normalized:</span><br><span class="line">        <span class="comment"># 需要将余弦相似度转化成类似欧氏距离的余弦距离。</span></span><br><span class="line">        a = np.asarray(a) / np.linalg.norm(a, axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line">        <span class="comment">#  np.linalg.norm 操作是求向量的范式，默认是L2范式，等同于求向量的欧式距离。</span></span><br><span class="line">        b = np.asarray(b) / np.linalg.norm(b, axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.</span> - np.dot(a, b.T)</span><br></pre></td></tr></table></figure>
<center><img src="https://pic2.zhimg.com/80/v2-cec3dfff80f4d4c8ccc34fb3636c1b6d_1440w.jpg" alt="img" style="zoom:50%;"></center>
<p>以上代码对应公式，注意<strong>余弦距离 = 1 - 余弦相似度</strong>。</p>
<h6><span id="最近邻距离度量类"> 最近邻距离度量类</span></h6>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NearestNeighborDistanceMetric</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="comment"># 对于每个目标，返回一个最近的距离</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, metric, matching_threshold, budget=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="comment"># 默认matching_threshold = 0.2 budge = 100</span></span><br><span class="line">        <span class="keyword">if</span> metric == <span class="string">&quot;euclidean&quot;</span>:</span><br><span class="line">            <span class="comment"># 使用最近邻欧氏距离</span></span><br><span class="line">            self._metric = _nn_euclidean_distance</span><br><span class="line">        <span class="keyword">elif</span> metric == <span class="string">&quot;cosine&quot;</span>:</span><br><span class="line">            <span class="comment"># 使用最近邻余弦距离</span></span><br><span class="line">            self._metric = _nn_cosine_distance</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;Invalid metric; must be either &#x27;euclidean&#x27; or &#x27;cosine&#x27;&quot;</span>)</span><br><span class="line"></span><br><span class="line">        self.matching_threshold = matching_threshold</span><br><span class="line">        <span class="comment"># 在级联匹配的函数中调用</span></span><br><span class="line">        self.budget = budget</span><br><span class="line">        <span class="comment"># budge 预算，控制feature的多少</span></span><br><span class="line">        self.samples = &#123;&#125;</span><br><span class="line">        <span class="comment"># samples是一个字典&#123;id-&gt;feature list&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partial_fit</span>(<span class="params">self, features, targets, active_targets</span>):</span></span><br><span class="line">        <span class="comment"># 作用：部分拟合，用新的数据更新测量距离</span></span><br><span class="line">        <span class="comment"># 调用：在特征集更新模块部分调用，tracker.update()中</span></span><br><span class="line">        <span class="keyword">for</span> feature, target <span class="keyword">in</span> <span class="built_in">zip</span>(features, targets):</span><br><span class="line">            self.samples.setdefault(target, []).append(feature)</span><br><span class="line">            <span class="comment"># 对应目标下添加新的feature，更新feature集合</span></span><br><span class="line">            <span class="comment"># 目标id  :  feature list</span></span><br><span class="line">            <span class="keyword">if</span> self.budget <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                self.samples[target] = self.samples[target][-self.budget:]</span><br><span class="line">            <span class="comment"># 设置预算，每个类最多多少个目标，超过直接忽略</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 筛选激活的目标</span></span><br><span class="line">        self.samples = &#123;k: self.samples[k] <span class="keyword">for</span> k <span class="keyword">in</span> active_targets&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">distance</span>(<span class="params">self, features, targets</span>):</span></span><br><span class="line">        <span class="comment"># 作用：比较feature和targets之间的距离，返回一个代价矩阵</span></span><br><span class="line">        <span class="comment"># 调用：在匹配阶段，将distance封装为gated_metric,</span></span><br><span class="line">        <span class="comment">#       进行外观信息(reid得到的深度特征)+</span></span><br><span class="line">        <span class="comment">#       运动信息(马氏距离用于度量两个分布相似程度)</span></span><br><span class="line">        cost_matrix = np.zeros((<span class="built_in">len</span>(targets), <span class="built_in">len</span>(features)))</span><br><span class="line">        <span class="keyword">for</span> i, target <span class="keyword">in</span> <span class="built_in">enumerate</span>(targets):</span><br><span class="line">            cost_matrix[i, :] = self._metric(self.samples[target], features)</span><br><span class="line">        <span class="keyword">return</span> cost_matrix</span><br></pre></td></tr></table></figure>
<h6><span id="tracker-类"> Tracker 类</span></h6>
<p>Tracker 类是最核心的类，Tracker 中保存了所有的轨迹信息，负责初始化第一帧的轨迹、卡尔曼滤波的预测和更新、负责级联匹配、IOU 匹配等等核心工作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tracker</span>:</span></span><br><span class="line">    <span class="comment"># 是一个多目标tracker，保存了很多个track轨迹</span></span><br><span class="line">    <span class="comment"># 负责调用卡尔曼滤波来预测track的新状态+进行匹配工作+初始化第一帧</span></span><br><span class="line">    <span class="comment"># Tracker调用update或predict的时候，其中的每个track也会各自调用自己的update或predict</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    This is the multi-target tracker.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, metric, max_iou_distance=<span class="number">0.7</span>, max_age=<span class="number">70</span>, n_init=<span class="number">3</span></span>):</span></span><br><span class="line">        <span class="comment"># 调用的时候，后边的参数全部是默认的</span></span><br><span class="line">        self.metric = metric </span><br><span class="line">        <span class="comment"># metric是一个类，用于计算距离(余弦距离或马氏距离)</span></span><br><span class="line">        self.max_iou_distance = max_iou_distance</span><br><span class="line">        <span class="comment"># 最大iou，iou匹配的时候使用</span></span><br><span class="line">        self.max_age = max_age</span><br><span class="line">        <span class="comment"># 直接指定级联匹配的cascade_depth参数</span></span><br><span class="line">        self.n_init = n_init</span><br><span class="line">        <span class="comment"># n_init代表需要n_init次数的update才会将track状态设置为confirmed</span></span><br><span class="line"></span><br><span class="line">        self.kf = kalman_filter.KalmanFilter()<span class="comment"># 卡尔曼滤波器</span></span><br><span class="line">        self.tracks = [] <span class="comment"># 保存一系列轨迹</span></span><br><span class="line">        self._next_id = <span class="number">1</span> <span class="comment"># 下一个分配的轨迹id</span></span><br><span class="line"> 	<span class="function"><span class="keyword">def</span> <span class="title">predict</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 遍历每个track都进行一次预测</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Propagate track state distributions one time step forward.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        This function should be called once every time step, before `update`.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> track <span class="keyword">in</span> self.tracks:</span><br><span class="line">            track.predict(self.kf)</span><br></pre></td></tr></table></figure>
<p>然后来看最核心的 update 函数和 match 函数，可以对照下面的流程图一起看：</p>
<p><strong>update 函数</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">self, detections</span>):</span></span><br><span class="line">    <span class="comment"># 进行测量的更新和轨迹管理</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Perform measurement update and track management.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    detections : List[deep_sort.detection.Detection]</span></span><br><span class="line"><span class="string">        A list of detections at the current time step.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># Run matching cascade.</span></span><br><span class="line">    matches, unmatched_tracks, unmatched_detections = \</span><br><span class="line">        self._match(detections)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Update track set.</span></span><br><span class="line">    <span class="comment"># 1. 针对匹配上的结果</span></span><br><span class="line">    <span class="keyword">for</span> track_idx, detection_idx <span class="keyword">in</span> matches:</span><br><span class="line">        <span class="comment"># track更新对应的detection</span></span><br><span class="line">        self.tracks[track_idx].update(self.kf, detections[detection_idx])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 针对未匹配的tracker,调用mark_missed标记</span></span><br><span class="line">    <span class="comment"># track失配，若待定则删除，若update时间很久也删除</span></span><br><span class="line">    <span class="comment"># max age是一个存活期限，默认为70帧</span></span><br><span class="line">    <span class="keyword">for</span> track_idx <span class="keyword">in</span> unmatched_tracks:</span><br><span class="line">        self.tracks[track_idx].mark_missed()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 针对未匹配的detection， detection失配，进行初始化</span></span><br><span class="line">    <span class="keyword">for</span> detection_idx <span class="keyword">in</span> unmatched_detections:</span><br><span class="line">        self._initiate_track(detections[detection_idx])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 得到最新的tracks列表，保存的是标记为confirmed和Tentative的track</span></span><br><span class="line">    self.tracks = [t <span class="keyword">for</span> t <span class="keyword">in</span> self.tracks <span class="keyword">if</span> <span class="keyword">not</span> t.is_deleted()]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Update distance metric.</span></span><br><span class="line">    active_targets = [t.track_id <span class="keyword">for</span> t <span class="keyword">in</span> self.tracks <span class="keyword">if</span> t.is_confirmed()]</span><br><span class="line">    <span class="comment"># 获取所有confirmed状态的track id</span></span><br><span class="line">    features, targets = [], []</span><br><span class="line">    <span class="keyword">for</span> track <span class="keyword">in</span> self.tracks:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> track.is_confirmed():</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        features += track.features  <span class="comment"># 将tracks列表拼接到features列表</span></span><br><span class="line">        <span class="comment"># 获取每个feature对应的track id</span></span><br><span class="line">        targets += [track.track_id <span class="keyword">for</span> _ <span class="keyword">in</span> track.features]</span><br><span class="line">        track.features = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 距离度量中的 特征集更新</span></span><br><span class="line">    self.metric.partial_fit(np.asarray(features), np.asarray(targets),</span><br><span class="line">                            active_targets)</span><br></pre></td></tr></table></figure>
<p><strong>match 函数：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_match</span>(<span class="params">self, detections</span>):</span></span><br><span class="line">    <span class="comment"># 主要功能是进行匹配，找到匹配的，未匹配的部分</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gated_metric</span>(<span class="params">tracks, dets, track_indices, detection_indices</span>):</span></span><br><span class="line">        <span class="comment"># 功能： 用于计算track和detection之间的距离，代价函数</span></span><br><span class="line">        <span class="comment">#        需要使用在KM算法之前</span></span><br><span class="line">        <span class="comment"># 调用：</span></span><br><span class="line">        <span class="comment"># cost_matrix = distance_metric(tracks, detections,</span></span><br><span class="line">        <span class="comment">#                  track_indices, detection_indices)</span></span><br><span class="line">        features = np.array([dets[i].feature <span class="keyword">for</span> i <span class="keyword">in</span> detection_indices])</span><br><span class="line">        targets = np.array([tracks[i].track_id <span class="keyword">for</span> i <span class="keyword">in</span> track_indices])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 1. 通过最近邻计算出代价矩阵 cosine distance</span></span><br><span class="line">        cost_matrix = self.metric.distance(features, targets)</span><br><span class="line">        <span class="comment"># 2. 计算马氏距离,得到新的状态矩阵</span></span><br><span class="line">        cost_matrix = linear_assignment.gate_cost_matrix(</span><br><span class="line">            self.kf, cost_matrix, tracks, dets, track_indices,</span><br><span class="line">            detection_indices)</span><br><span class="line">        <span class="keyword">return</span> cost_matrix</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Split track set into confirmed and unconfirmed tracks.</span></span><br><span class="line">    <span class="comment"># 划分不同轨迹的状态</span></span><br><span class="line">    confirmed_tracks = [</span><br><span class="line">        i <span class="keyword">for</span> i, t <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.tracks) <span class="keyword">if</span> t.is_confirmed()</span><br><span class="line">    ]</span><br><span class="line">    unconfirmed_tracks = [</span><br><span class="line">        i <span class="keyword">for</span> i, t <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.tracks) <span class="keyword">if</span> <span class="keyword">not</span> t.is_confirmed()</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 进行级联匹配，得到匹配的track、不匹配的track、不匹配的detection</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    !!!!!!!!!!!</span></span><br><span class="line"><span class="string">    级联匹配</span></span><br><span class="line"><span class="string">    !!!!!!!!!!!</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># gated_metric-&gt;cosine distance</span></span><br><span class="line">    <span class="comment"># 仅仅对确定态的轨迹进行级联匹配</span></span><br><span class="line">    matches_a, unmatched_tracks_a, unmatched_detections = \</span><br><span class="line">        linear_assignment.matching_cascade(</span><br><span class="line">            gated_metric,</span><br><span class="line">            self.metric.matching_threshold,</span><br><span class="line">            self.max_age,</span><br><span class="line">            self.tracks,</span><br><span class="line">            detections,</span><br><span class="line">            confirmed_tracks)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将所有状态为未确定态的轨迹和刚刚没有匹配上的轨迹组合为iou_track_candidates，</span></span><br><span class="line">    <span class="comment"># 进行IoU的匹配</span></span><br><span class="line">    iou_track_candidates = unconfirmed_tracks + [</span><br><span class="line">        k <span class="keyword">for</span> k <span class="keyword">in</span> unmatched_tracks_a</span><br><span class="line">        <span class="keyword">if</span> self.tracks[k].time_since_update == <span class="number">1</span>  <span class="comment"># 刚刚没有匹配上</span></span><br><span class="line">    ]</span><br><span class="line">    <span class="comment"># 未匹配</span></span><br><span class="line">    unmatched_tracks_a = [</span><br><span class="line">        k <span class="keyword">for</span> k <span class="keyword">in</span> unmatched_tracks_a</span><br><span class="line">        <span class="keyword">if</span> self.tracks[k].time_since_update != <span class="number">1</span>  <span class="comment"># 已经很久没有匹配上</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    !!!!!!!!!!!</span></span><br><span class="line"><span class="string">    IOU 匹配</span></span><br><span class="line"><span class="string">    对级联匹配中还没有匹配成功的目标再进行IoU匹配</span></span><br><span class="line"><span class="string">    !!!!!!!!!!!</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 虽然和级联匹配中使用的都是min_cost_matching作为核心，</span></span><br><span class="line">    <span class="comment"># 这里使用的metric是iou cost和以上不同</span></span><br><span class="line">    matches_b, unmatched_tracks_b, unmatched_detections = \</span><br><span class="line">        linear_assignment.min_cost_matching(</span><br><span class="line">            iou_matching.iou_cost,</span><br><span class="line">            self.max_iou_distance,</span><br><span class="line">            self.tracks,</span><br><span class="line">            detections,</span><br><span class="line">            iou_track_candidates,</span><br><span class="line">            unmatched_detections)</span><br><span class="line"></span><br><span class="line">    matches = matches_a + matches_b  <span class="comment"># 组合两部分match得到的结果</span></span><br><span class="line"></span><br><span class="line">    unmatched_tracks = <span class="built_in">list</span>(<span class="built_in">set</span>(unmatched_tracks_a + unmatched_tracks_b))</span><br><span class="line">    <span class="keyword">return</span> matches, unmatched_tracks, unmatched_detections</span><br></pre></td></tr></table></figure>
<p>以上两部分结合注释和以下流程图可以更容易理解。</p>
<center><img src="https://pic3.zhimg.com/80/v2-e3993a920cea6df12c56ac9603d4e7da_1440w.jpg" alt="img" style="zoom: 90%;"></center>
<h6><span id="级联匹配"> 级联匹配</span></h6>
<p>下边是论文中给出的级联匹配的伪代码：</p>
<center><img src="https://pic4.zhimg.com/80/v2-73da349ebf5c4b8e765798de8bad4be7_1440w.jpg" alt="img" style="zoom: 33%;"></center>
<p>以下代码是伪代码对应的实现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 分配track_indices和detection_indices</span></span><br><span class="line"><span class="keyword">if</span> track_indices <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    track_indices = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="built_in">len</span>(tracks)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> detection_indices <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    detection_indices = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="built_in">len</span>(detections)))</span><br><span class="line"></span><br><span class="line">unmatched_detections = detection_indices</span><br><span class="line"></span><br><span class="line">matches = []</span><br><span class="line"><span class="comment"># cascade depth = max age 默认为70</span></span><br><span class="line"><span class="keyword">for</span> level <span class="keyword">in</span> <span class="built_in">range</span>(cascade_depth):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(unmatched_detections) == <span class="number">0</span>:  <span class="comment"># No detections left</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    track_indices_l = [</span><br><span class="line">        k <span class="keyword">for</span> k <span class="keyword">in</span> track_indices</span><br><span class="line">        <span class="keyword">if</span> tracks[k].time_since_update == <span class="number">1</span> + level</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(track_indices_l) == <span class="number">0</span>:  <span class="comment"># Nothing to match at this level</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 级联匹配核心内容就是这个函数</span></span><br><span class="line">    matches_l, _, unmatched_detections = \</span><br><span class="line">        min_cost_matching(  <span class="comment"># max_distance=0.2</span></span><br><span class="line">            distance_metric, max_distance, tracks, detections,</span><br><span class="line">            track_indices_l, unmatched_detections)</span><br><span class="line">    matches += matches_l</span><br><span class="line">unmatched_tracks = <span class="built_in">list</span>(<span class="built_in">set</span>(track_indices) - <span class="built_in">set</span>(k <span class="keyword">for</span> k, _ <span class="keyword">in</span> matches))</span><br></pre></td></tr></table></figure>
<h6><span id="门控矩阵"> 门控矩阵</span></h6>
<p>门控矩阵的作用就是通过计算<strong>卡尔曼滤波的状态分布和测量值之间的距离</strong>对代价矩阵进行限制。</p>
<p>代价矩阵中的距离是 Track 和 Detection 之间的表观相似度，假如一个轨迹要去匹配两个表观特征非常相似的 Detection，这样就很容易出错，但是这个时候分别让两个 Detection 计算与这个轨迹的马氏距离，并使用一个阈值 gating_threshold 进行限制，所以就可以将马氏距离较远的那个 Detection 区分开，可以降低错误的匹配。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gate_cost_matrix</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        kf, cost_matrix, tracks, detections, track_indices, detection_indices,</span></span></span><br><span class="line"><span class="function"><span class="params">        gated_cost=INFTY_COST, only_position=<span class="literal">False</span></span>):</span></span><br><span class="line">    <span class="comment"># 根据通过卡尔曼滤波获得的状态分布，使成本矩阵中的不可行条目无效。</span></span><br><span class="line">    gating_dim = <span class="number">2</span> <span class="keyword">if</span> only_position <span class="keyword">else</span> <span class="number">4</span></span><br><span class="line">    gating_threshold = kalman_filter.chi2inv95[gating_dim]  <span class="comment"># 9.4877</span></span><br><span class="line"></span><br><span class="line">    measurements = np.asarray([detections[i].to_xyah()</span><br><span class="line">                               <span class="keyword">for</span> i <span class="keyword">in</span> detection_indices])</span><br><span class="line">    <span class="keyword">for</span> row, track_idx <span class="keyword">in</span> <span class="built_in">enumerate</span>(track_indices):</span><br><span class="line">        track = tracks[track_idx]</span><br><span class="line">        gating_distance = kf.gating_distance(</span><br><span class="line">            track.mean, track.covariance, measurements, only_position)</span><br><span class="line">        cost_matrix[row, gating_distance &gt;</span><br><span class="line">                    gating_threshold] = gated_cost  <span class="comment"># 设置为inf</span></span><br><span class="line">    <span class="keyword">return</span> cost_matrix</span><br></pre></td></tr></table></figure>
<h6><span id="卡尔曼滤波器"> 卡尔曼滤波器</span></h6>
<p>在 Deep SORT 中，需要估计 Track 的以下状态：</p>
<ul>
<li>均值：用 8 维向量（x, y, a, h, vx, vy, va, vh）表示。(x,y) 是框的中心坐标，宽高比是 a, 高度 h 以及对应的速度，所有的速度都将初始化为 0。</li>
<li>协方差：表示目标位置信息的不确定程度，用 8x8 的对角矩阵来表示，矩阵对应的值越大，代表不确定程度越高。</li>
</ul>
<p>下图代表卡尔曼滤波器主要过程：</p>
<center><img src="https://pic2.zhimg.com/80/v2-101b77477f3e96f762ac71029058f621_1440w.jpg" alt="img" style="zoom: 67%;"></center>
<ol>
<li>卡尔曼滤波首先根据当前帧 (time=t) 的状态进行<strong>预测</strong>，得到预测下一帧的状态 (time=t+1)</li>
<li>得到测量结果，在 Deep SORT 中对应的测量就是 Detection，即目标检测器提供的检测框。</li>
<li>将预测结果和测量结果进行<strong>更新</strong>。</li>
</ol>
<p>下面这部分主要参考： <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/90835266">https://zhuanlan.zhihu.com/p/90835266</a></p>
<p>如果对卡尔曼滤波算法有较为深入的了解，可以结合卡尔曼滤波算法和代码进行理解。</p>
<p><strong>预测分两个公式：</strong></p>
<p>第一个公式：</p>
<center><img src="https://www.zhihu.com/equation?tex=x%27%3DFx+%5C%5C" alt="[公式]" style="zoom: 90%;"></center>
<p>其中 F 是状态转移矩阵，如下图：</p>
<center><img src="https://pic1.zhimg.com/80/v2-c3548868fe9a0a32461752c33434dae8_1440w.jpg" alt="img" style="zoom: 80%;"></center>
<p>第二个公式：</p>
<center><img src="https://www.zhihu.com/equation?tex=P%27%3DFPF%5ET%2BQ+%5C%5C" alt="[公式]" style="zoom:90%;"></center>
<p>P 是当前帧 (time=t) 的协方差，Q 是卡尔曼滤波器的运动估计误差，代表不确定程度。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span>(<span class="params">self, mean, covariance</span>):</span></span><br><span class="line">    <span class="comment"># 相当于得到t时刻估计值</span></span><br><span class="line">    <span class="comment"># Q 预测过程中噪声协方差</span></span><br><span class="line">    std_pos = [</span><br><span class="line">        self._std_weight_position * mean[<span class="number">3</span>],</span><br><span class="line">        self._std_weight_position * mean[<span class="number">3</span>],</span><br><span class="line">        <span class="number">1e-2</span>,</span><br><span class="line">        self._std_weight_position * mean[<span class="number">3</span>]]</span><br><span class="line"></span><br><span class="line">    std_vel = [</span><br><span class="line">        self._std_weight_velocity * mean[<span class="number">3</span>],</span><br><span class="line">        self._std_weight_velocity * mean[<span class="number">3</span>],</span><br><span class="line">        <span class="number">1e-5</span>,</span><br><span class="line">        self._std_weight_velocity * mean[<span class="number">3</span>]]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># np.r_ 按列连接两个矩阵</span></span><br><span class="line">    <span class="comment"># 初始化噪声矩阵Q</span></span><br><span class="line">    motion_cov = np.diag(np.square(np.r_[std_pos, std_vel]))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># x&#x27; = Fx</span></span><br><span class="line">    mean = np.dot(self._motion_mat, mean)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># P&#x27; = FPF^T+Q</span></span><br><span class="line">    covariance = np.linalg.multi_dot((</span><br><span class="line">        self._motion_mat, covariance, self._motion_mat.T)) + motion_cov</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mean, covariance</span><br></pre></td></tr></table></figure>
<p><strong>更新的公式</strong></p>
<center><img src="https://www.zhihu.com/equation?tex=y%3Dz-Hx%27+%5C%5C+%5C%5C" alt="[公式]" style="zoom:90%;"></center>
<center><img src="https://www.zhihu.com/equation?tex=S%3DHP%27H%5ET%2BR+%5C%5C+%5C%5C" alt="[公式]" style="zoom:90%;"></center>
<center><img src="https://www.zhihu.com/equation?tex=K%3DP%27H%5ETS%5E%7B-1%7D+%5C%5C+%5C%5C" alt="[公式]" style="zoom:90%;"></center>
<center><img src="https://www.zhihu.com/equation?tex=x%3Dx%27%2BKy+%5C%5C+%5C%5C" alt="[公式]" style="zoom:90%;"></center>
<center><img src="https://www.zhihu.com/equation?tex=P%3D%28I-KH%29P%27+%5C%5C" alt="[公式]" style="zoom:90%;"></center>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">project</span>(<span class="params">self, mean, covariance</span>):</span></span><br><span class="line">    <span class="comment"># R 测量过程中噪声的协方差</span></span><br><span class="line">    std = [</span><br><span class="line">        self._std_weight_position * mean[<span class="number">3</span>],</span><br><span class="line">        self._std_weight_position * mean[<span class="number">3</span>],</span><br><span class="line">        <span class="number">1e-1</span>,</span><br><span class="line">        self._std_weight_position * mean[<span class="number">3</span>]]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化噪声矩阵R</span></span><br><span class="line">    innovation_cov = np.diag(np.square(std))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将均值向量映射到检测空间，即Hx&#x27;</span></span><br><span class="line">    mean = np.dot(self._update_mat, mean)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将协方差矩阵映射到检测空间，即HP&#x27;H^T</span></span><br><span class="line">    covariance = np.linalg.multi_dot((</span><br><span class="line">        self._update_mat, covariance, self._update_mat.T))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mean, covariance + innovation_cov</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">self, mean, covariance, measurement</span>):</span></span><br><span class="line">    <span class="comment"># 通过估计值和观测值估计最新结果</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将均值和协方差映射到检测空间，得到 Hx&#x27; 和 S</span></span><br><span class="line">    projected_mean, projected_cov = self.project(mean, covariance)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 矩阵分解</span></span><br><span class="line">    chol_factor, lower = scipy.linalg.cho_factor(</span><br><span class="line">        projected_cov, lower=<span class="literal">True</span>, check_finite=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算卡尔曼增益K</span></span><br><span class="line">    kalman_gain = scipy.linalg.cho_solve(</span><br><span class="line">        (chol_factor, lower), np.dot(covariance, self._update_mat.T).T,</span><br><span class="line">        check_finite=<span class="literal">False</span>).T</span><br><span class="line"></span><br><span class="line">    <span class="comment"># z - Hx&#x27;</span></span><br><span class="line">    innovation = measurement - projected_mean</span><br><span class="line"></span><br><span class="line">    <span class="comment"># x = x&#x27; + Ky</span></span><br><span class="line">    new_mean = mean + np.dot(innovation, kalman_gain.T)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># P = (I - KH)P&#x27;</span></span><br><span class="line">    new_covariance = covariance - np.linalg.multi_dot((</span><br><span class="line">        kalman_gain, projected_cov, kalman_gain.T))</span><br><span class="line">    <span class="keyword">return</span> new_mean, new_covariance</span><br></pre></td></tr></table></figure>
<center><img src="https://www.zhihu.com/equation?tex=y%3Dz-Hx%27+%5C%5C" alt="[公式]" style="zoom:90%;"></center>
<p>这个公式中，z 是 Detection 的 mean，不包含变化值，状态为 [cx,cy,a,h]。H 是测量矩阵，将 Track 的均值向量<img src="https://www.zhihu.com/equation?tex=x%27" alt="[公式]"> 映射到检测空间。计算的 y 是 Detection 和 Track 的均值误差。</p>
<center><img src="https://www.zhihu.com/equation?tex=S%3DHP%27H%5ET%2BR+%5C%5C" alt="[公式]" style="zoom:90%;"></center>
<p>R 是目标检测器的噪声矩阵，是一个 4x4 的对角矩阵。 对角线上的值分别为中心点两个坐标以及宽高的噪声。</p>
<center><img src="https://www.zhihu.com/equation?tex=K%3DP%27H%5ETS%5E%7B-1%7D+%5C%5C" alt="[公式]" style="zoom:90%;"></center>
<p>计算的是卡尔曼增益，是作用于衡量估计误差的权重。</p>
<center><img src="https://www.zhihu.com/equation?tex=x%3Dx%27%2BKy+%5C%5C" alt="[公式]" style="zoom:90%;"></center>
<p>更新后的均值向量 x。</p>
<center><img src="https://www.zhihu.com/equation?tex=P%3D%28I-KH%29P%27+%5C%5C" alt="[公式]" style="zoom:80%;"></center>
<p>更新后的协方差矩阵。</p>
<p>卡尔曼滤波笔者理解也不是很深入，没有推导过公式，对这部分感兴趣的推荐几个博客：</p>
<ol>
<li>卡尔曼滤波 + python 写的 demo: <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/113685503?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=801414067897135104">https://zhuanlan.zhihu.com/p/113685503?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=801414067897135104</a></li>
<li>详解 + 推导： <a href="https://link.zhihu.com/?target=https%3A//blog.csdn.net/honyniu/article/details/88697520">https://blog.csdn.net/honyniu/a</a></li>
</ol>
<h4><span id="5-流程解析"> 5. 流程解析</span></h4>
<p>流程部分主要按照以下流程图来走一遍：</p>
<center><img src="https://pic1.zhimg.com/80/v2-baea18c4eceb6bbf810b8225d358defc_1440w.jpg" alt="img" style="zoom:50%;"></center>
<p>感谢知乎 @猫弟总结的流程图，讲解非常地清晰，如果单纯看代码，非常容易混淆。比如说代价矩阵的计算这部分，连续套了三个函数，才被真正调用。上图将整体流程总结地非常棒。笔者将参考以上流程结合代码进行梳理：</p>
<ol>
<li>分析 detector 类中的 Deep SORT 调用：</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Detector</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, args</span>):</span></span><br><span class="line">        self.args = args</span><br><span class="line">        <span class="keyword">if</span> args.display:</span><br><span class="line">            cv2.namedWindow(<span class="string">&quot;test&quot;</span>, cv2.WINDOW_NORMAL)</span><br><span class="line">            cv2.resizeWindow(<span class="string">&quot;test&quot;</span>, args.display_width, args.display_height)</span><br><span class="line"></span><br><span class="line">        device = torch.device(</span><br><span class="line">            <span class="string">&#x27;cuda&#x27;</span>) <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> torch.device(<span class="string">&#x27;cpu&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        self.vdo = cv2.VideoCapture()</span><br><span class="line">        self.yolo3 = InferYOLOv3(args.yolo_cfg,</span><br><span class="line">                                 args.img_size,</span><br><span class="line">                                 args.yolo_weights,</span><br><span class="line">                                 args.data_cfg,</span><br><span class="line">                                 device,</span><br><span class="line">                                 conf_thres=args.conf_thresh,</span><br><span class="line">                                 nms_thres=args.nms_thresh)</span><br><span class="line">        self.deepsort = DeepSort(args.deepsort_checkpoint)</span><br></pre></td></tr></table></figure>
<p>初始化 DeepSORT 对象，更新部分接收目标检测得到的框的位置，置信度和图片：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outputs = self.deepsort.update(bbox_xcycwh, cls_conf, im)</span><br></pre></td></tr></table></figure>
<ol>
<li>顺着 DeepSORT 类的 update 函数看</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeepSort</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, model_path, max_dist=<span class="number">0.2</span></span>):</span></span><br><span class="line">        self.min_confidence = <span class="number">0.3</span></span><br><span class="line">        <span class="comment"># yolov3中检测结果置信度阈值，筛选置信度小于0.3的detection。</span></span><br><span class="line"></span><br><span class="line">        self.nms_max_overlap = <span class="number">1.0</span></span><br><span class="line">        <span class="comment"># 非极大抑制阈值，设置为1代表不进行抑制</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 用于提取图片的embedding,返回的是一个batch图片对应的特征</span></span><br><span class="line">        self.extractor = Extractor(<span class="string">&quot;resnet18&quot;</span>,</span><br><span class="line">                                   model_path,</span><br><span class="line">                                   use_cuda=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        max_cosine_distance = max_dist</span><br><span class="line">        <span class="comment"># 用在级联匹配的地方，如果大于改阈值，就直接忽略</span></span><br><span class="line">        nn_budget = <span class="number">100</span></span><br><span class="line">        <span class="comment"># 预算，每个类别最多的样本个数，如果超过，删除旧的</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第一个参数可选&#x27;cosine&#x27; or &#x27;euclidean&#x27;</span></span><br><span class="line">        metric = NearestNeighborDistanceMetric(<span class="string">&quot;cosine&quot;</span>,</span><br><span class="line">                                               max_cosine_distance,</span><br><span class="line">                                               nn_budget)</span><br><span class="line">        self.tracker = Tracker(metric)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">self, bbox_xywh, confidences, ori_img</span>):</span></span><br><span class="line">        self.height, self.width = ori_img.shape[:<span class="number">2</span>]</span><br><span class="line">        <span class="comment"># generate detections</span></span><br><span class="line">        features = self._get_features(bbox_xywh, ori_img)</span><br><span class="line">        <span class="comment"># 从原图中crop bbox对应图片并计算得到embedding</span></span><br><span class="line">        bbox_tlwh = self._xywh_to_tlwh(bbox_xywh)</span><br><span class="line"></span><br><span class="line">        detections = [</span><br><span class="line">            Detection(bbox_tlwh[i], conf, features[i])</span><br><span class="line">            <span class="keyword">for</span> i, conf <span class="keyword">in</span> <span class="built_in">enumerate</span>(confidences) <span class="keyword">if</span> conf &gt; self.min_confidence</span><br><span class="line">        ]  <span class="comment"># 筛选小于min_confidence的目标，并构造一个Detection对象构成的列表</span></span><br><span class="line">        <span class="comment"># Detection是一个存储图中一个bbox结果</span></span><br><span class="line">        <span class="comment"># 需要：1. bbox(tlwh形式) 2. 对应置信度 3. 对应embedding</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># run on non-maximum supression</span></span><br><span class="line">        boxes = np.array([d.tlwh <span class="keyword">for</span> d <span class="keyword">in</span> detections])</span><br><span class="line">        scores = np.array([d.confidence <span class="keyword">for</span> d <span class="keyword">in</span> detections])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 使用非极大抑制</span></span><br><span class="line">        <span class="comment"># 默认nms_thres=1的时候开启也没有用，实际上并没有进行非极大抑制</span></span><br><span class="line">        indices = non_max_suppression(boxes, self.nms_max_overlap, scores)</span><br><span class="line">        detections = [detections[i] <span class="keyword">for</span> i <span class="keyword">in</span> indices]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># update tracker</span></span><br><span class="line">        <span class="comment"># tracker给出一个预测结果，然后将detection传入，进行卡尔曼滤波操作</span></span><br><span class="line">        self.tracker.predict()</span><br><span class="line">        self.tracker.update(detections)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># output bbox identities</span></span><br><span class="line">        <span class="comment"># 存储结果以及可视化</span></span><br><span class="line">        outputs = []</span><br><span class="line">        <span class="keyword">for</span> track <span class="keyword">in</span> self.tracker.tracks:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> track.is_confirmed() <span class="keyword">or</span> track.time_since_update &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            box = track.to_tlwh()</span><br><span class="line">            x1, y1, x2, y2 = self._tlwh_to_xyxy(box)</span><br><span class="line">            track_id = track.track_id</span><br><span class="line">            outputs.append(np.array([x1, y1, x2, y2, track_id], dtype=np.<span class="built_in">int</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(outputs) &gt; <span class="number">0</span>:</span><br><span class="line">            outputs = np.stack(outputs, axis=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> np.array(outputs)</span><br></pre></td></tr></table></figure>
<p>从这里开始对照以上流程图会更加清晰。在 Deep SORT 初始化的过程中有一个核心 metric，NearestNeighborDistanceMetric 类会在匹配和特征集更新的时候用到。</p>
<p>梳理 DeepSORT 的 update 流程：</p>
<ul>
<li>根据传入的参数（bbox_xywh, conf, img）使用 ReID 模型提取对应 bbox 的表观特征。</li>
<li>构建 detections 的列表，列表中的内容就是 Detection 类，在此处限制了 bbox 的最小置信度。</li>
<li>使用非极大抑制算法，由于默认 nms_thres=1，实际上并没有用。</li>
<li>Tracker 类进行一次预测，然后将 detections 传入，进行更新。</li>
<li>最后将 Tracker 中保存的轨迹中状态属于确认态的轨迹返回。</li>
</ul>
<p>以上核心在 Tracker 的 predict 和 update 函数，接着梳理。</p>
<ol>
<li>Tracker 的 predict 函数</li>
</ol>
<p>Tracker 是一个多目标跟踪器，保存了很多个 track 轨迹，负责调用卡尔曼滤波来预测 track 的新状态 + 进行匹配工作 + 初始化第一帧。Tracker 调用 update 或 predict 的时候，其中的每个 track 也会各自调用自己的 update 或 predict</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tracker</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, metric, max_iou_distance=<span class="number">0.7</span>, max_age=<span class="number">70</span>, n_init=<span class="number">3</span></span>):</span></span><br><span class="line">        <span class="comment"># 调用的时候，后边的参数全部是默认的</span></span><br><span class="line">        self.metric = metric</span><br><span class="line">        self.max_iou_distance = max_iou_distance</span><br><span class="line">        <span class="comment"># 最大iou，iou匹配的时候使用</span></span><br><span class="line">        self.max_age = max_age</span><br><span class="line">        <span class="comment"># 直接指定级联匹配的cascade_depth参数</span></span><br><span class="line">        self.n_init = n_init</span><br><span class="line">        <span class="comment"># n_init代表需要n_init次数的update才会将track状态设置为confirmed</span></span><br><span class="line"></span><br><span class="line">        self.kf = kalman_filter.KalmanFilter()  <span class="comment"># 卡尔曼滤波器</span></span><br><span class="line">        self.tracks = []  <span class="comment"># 保存一系列轨迹</span></span><br><span class="line">        self._next_id = <span class="number">1</span>  <span class="comment"># 下一个分配的轨迹id</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 遍历每个track都进行一次预测</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Propagate track state distributions one time step forward.</span></span><br><span class="line"><span class="string">        This function should be called once every time step, before `update`.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> track <span class="keyword">in</span> self.tracks:</span><br><span class="line">            track.predict(self.kf)</span><br></pre></td></tr></table></figure>
<p>predict 主要是对轨迹列表中所有的轨迹使用卡尔曼滤波算法进行状态的预测。</p>
<ol>
<li>Tracker 的更新</li>
</ol>
<p>Tracker 的更新属于最核心的部分。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">self, detections</span>):</span></span><br><span class="line">    <span class="comment"># 进行测量的更新和轨迹管理</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Perform measurement update and track management.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    detections : List[deep_sort.detection.Detection]</span></span><br><span class="line"><span class="string">        A list of detections at the current time step.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># Run matching cascade.</span></span><br><span class="line">    matches, unmatched_tracks, unmatched_detections = \</span><br><span class="line">        self._match(detections)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Update track set.</span></span><br><span class="line">    <span class="comment"># 1. 针对匹配上的结果</span></span><br><span class="line">    <span class="keyword">for</span> track_idx, detection_idx <span class="keyword">in</span> matches:</span><br><span class="line">        <span class="comment"># track更新对应的detection</span></span><br><span class="line">        self.tracks[track_idx].update(self.kf, detections[detection_idx])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 针对未匹配的tracker,调用mark_missed标记</span></span><br><span class="line">    <span class="comment"># track失配，若待定则删除，若update时间很久也删除</span></span><br><span class="line">    <span class="comment"># max age是一个存活期限，默认为70帧</span></span><br><span class="line">    <span class="keyword">for</span> track_idx <span class="keyword">in</span> unmatched_tracks:</span><br><span class="line">        self.tracks[track_idx].mark_missed()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 针对未匹配的detection， detection失配，进行初始化</span></span><br><span class="line">    <span class="keyword">for</span> detection_idx <span class="keyword">in</span> unmatched_detections:</span><br><span class="line">        self._initiate_track(detections[detection_idx])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 得到最新的tracks列表，保存的是标记为confirmed和Tentative的track</span></span><br><span class="line">    self.tracks = [t <span class="keyword">for</span> t <span class="keyword">in</span> self.tracks <span class="keyword">if</span> <span class="keyword">not</span> t.is_deleted()]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Update distance metric.</span></span><br><span class="line">    active_targets = [t.track_id <span class="keyword">for</span> t <span class="keyword">in</span> self.tracks <span class="keyword">if</span> t.is_confirmed()]</span><br><span class="line">    <span class="comment"># 获取所有confirmed状态的track id</span></span><br><span class="line">    features, targets = [], []</span><br><span class="line">    <span class="keyword">for</span> track <span class="keyword">in</span> self.tracks:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> track.is_confirmed():</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        features += track.features  <span class="comment"># 将tracks列表拼接到features列表</span></span><br><span class="line">        <span class="comment"># 获取每个feature对应的track id</span></span><br><span class="line">        targets += [track.track_id <span class="keyword">for</span> _ <span class="keyword">in</span> track.features]</span><br><span class="line">        track.features = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 距离度量中的 特征集更新</span></span><br><span class="line">    self.metric.partial_fit(np.asarray(features), np.asarray(targets),active_targets)</span><br></pre></td></tr></table></figure>
<p>这部分注释已经很详细了，主要是一些后处理代码，需要关注的是对匹配上的，未匹配的 Detection，未匹配的 Track 三者进行的处理以及最后进行特征集更新部分，可以对照流程图梳理。</p>
<p>Tracker 的 update 函数的核心函数是 match 函数，描述如何进行匹配的流程：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_match</span>(<span class="params">self, detections</span>):</span></span><br><span class="line">    <span class="comment"># 主要功能是进行匹配，找到匹配的，未匹配的部分</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gated_metric</span>(<span class="params">tracks, dets, track_indices, detection_indices</span>):</span></span><br><span class="line">        <span class="comment"># 功能： 用于计算track和detection之间的距离，代价函数</span></span><br><span class="line">        <span class="comment">#        需要使用在KM算法之前</span></span><br><span class="line">        <span class="comment"># 调用：</span></span><br><span class="line">        <span class="comment"># cost_matrix = distance_metric(tracks, detections,</span></span><br><span class="line">        <span class="comment">#                  track_indices, detection_indices)</span></span><br><span class="line">        features = np.array([dets[i].feature <span class="keyword">for</span> i <span class="keyword">in</span> detection_indices])</span><br><span class="line">        targets = np.array([tracks[i].track_id <span class="keyword">for</span> i <span class="keyword">in</span> track_indices])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 1. 通过最近邻计算出代价矩阵 cosine distance</span></span><br><span class="line">        cost_matrix = self.metric.distance(features, targets)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2. 计算马氏距离,得到新的状态矩阵</span></span><br><span class="line">        cost_matrix = linear_assignment.gate_cost_matrix(</span><br><span class="line">            self.kf, cost_matrix, tracks, dets, track_indices,</span><br><span class="line">            detection_indices)</span><br><span class="line">        <span class="keyword">return</span> cost_matrix</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Split track set into confirmed and unconfirmed tracks.</span></span><br><span class="line">    <span class="comment"># 划分不同轨迹的状态</span></span><br><span class="line">    confirmed_tracks = [</span><br><span class="line">        i <span class="keyword">for</span> i, t <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.tracks) <span class="keyword">if</span> t.is_confirmed()</span><br><span class="line">    ]</span><br><span class="line">    unconfirmed_tracks = [</span><br><span class="line">        i <span class="keyword">for</span> i, t <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.tracks) <span class="keyword">if</span> <span class="keyword">not</span> t.is_confirmed()</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 进行级联匹配，得到匹配的track、不匹配的track、不匹配的detection</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    !!!!!!!!!!!</span></span><br><span class="line"><span class="string">    级联匹配</span></span><br><span class="line"><span class="string">    !!!!!!!!!!!</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># gated_metric-&gt;cosine distance</span></span><br><span class="line">    <span class="comment"># 仅仅对确定态的轨迹进行级联匹配</span></span><br><span class="line">    matches_a, unmatched_tracks_a, unmatched_detections = \</span><br><span class="line">        linear_assignment.matching_cascade(</span><br><span class="line">            gated_metric,</span><br><span class="line">            self.metric.matching_threshold,</span><br><span class="line">            self.max_age,</span><br><span class="line">            self.tracks,</span><br><span class="line">            detections,</span><br><span class="line">            confirmed_tracks)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将所有状态为未确定态的轨迹和刚刚没有匹配上的轨迹组合为iou_track_candidates，</span></span><br><span class="line">    <span class="comment"># 进行IoU的匹配</span></span><br><span class="line">    iou_track_candidates = unconfirmed_tracks + [</span><br><span class="line">        k <span class="keyword">for</span> k <span class="keyword">in</span> unmatched_tracks_a</span><br><span class="line">        <span class="keyword">if</span> self.tracks[k].time_since_update == <span class="number">1</span>  <span class="comment"># 刚刚没有匹配上</span></span><br><span class="line">    ]</span><br><span class="line">    <span class="comment"># 未匹配</span></span><br><span class="line">    unmatched_tracks_a = [</span><br><span class="line">        k <span class="keyword">for</span> k <span class="keyword">in</span> unmatched_tracks_a</span><br><span class="line">        <span class="keyword">if</span> self.tracks[k].time_since_update != <span class="number">1</span>  <span class="comment"># 已经很久没有匹配上</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    !!!!!!!!!!!</span></span><br><span class="line"><span class="string">    IOU 匹配</span></span><br><span class="line"><span class="string">    对级联匹配中还没有匹配成功的目标再进行IoU匹配</span></span><br><span class="line"><span class="string">    !!!!!!!!!!!</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 虽然和级联匹配中使用的都是min_cost_matching作为核心，</span></span><br><span class="line">    <span class="comment"># 这里使用的metric是iou cost和以上不同</span></span><br><span class="line">    matches_b, unmatched_tracks_b, unmatched_detections = \</span><br><span class="line">        linear_assignment.min_cost_matching(</span><br><span class="line">            iou_matching.iou_cost,</span><br><span class="line">            self.max_iou_distance,</span><br><span class="line">            self.tracks,</span><br><span class="line">            detections,</span><br><span class="line">            iou_track_candidates,</span><br><span class="line">            unmatched_detections)</span><br><span class="line"></span><br><span class="line">    matches = matches_a + matches_b  <span class="comment"># 组合两部分match得到的结果</span></span><br><span class="line"></span><br><span class="line">    unmatched_tracks = <span class="built_in">list</span>(<span class="built_in">set</span>(unmatched_tracks_a + unmatched_tracks_b))</span><br><span class="line">    <span class="keyword">return</span> matches, unmatched_tracks, unmatched_detections</span><br></pre></td></tr></table></figure>
<p>对照下图来看会顺畅很多：</p>
<center><img src="https://pic3.zhimg.com/80/v2-e3993a920cea6df12c56ac9603d4e7da_1440w.jpg" alt="img" style="zoom: 80%;"></center>
<p>可以看到，匹配函数的核心是级联匹配 + IOU 匹配，先来看看级联匹配：</p>
<p>调用在这里：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">matches_a, unmatched_tracks_a, unmatched_detections = linear_assignment.matching_cascade(</span><br><span class="line">        gated_metric,</span><br><span class="line">        self.metric.matching_threshold,</span><br><span class="line">        self.max_age,</span><br><span class="line">        self.tracks,</span><br><span class="line">        detections,</span><br><span class="line">        confirmed_tracks)</span><br></pre></td></tr></table></figure>
<p>级联匹配函数展开：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">matching_cascade</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        distance_metric, max_distance, cascade_depth, tracks, detections,</span></span></span><br><span class="line"><span class="function"><span class="params">        track_indices=<span class="literal">None</span>, detection_indices=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="comment"># 级联匹配</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. 分配track_indices和detection_indices</span></span><br><span class="line">    <span class="keyword">if</span> track_indices <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        track_indices = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="built_in">len</span>(tracks)))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> detection_indices <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        detection_indices = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="built_in">len</span>(detections)))</span><br><span class="line"></span><br><span class="line">    unmatched_detections = detection_indices</span><br><span class="line"></span><br><span class="line">    matches = []</span><br><span class="line">    <span class="comment"># cascade depth = max age 默认为70</span></span><br><span class="line">    <span class="keyword">for</span> level <span class="keyword">in</span> <span class="built_in">range</span>(cascade_depth):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(unmatched_detections) == <span class="number">0</span>:  <span class="comment"># No detections left</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        track_indices_l = [</span><br><span class="line">            k <span class="keyword">for</span> k <span class="keyword">in</span> track_indices</span><br><span class="line">            <span class="keyword">if</span> tracks[k].time_since_update == <span class="number">1</span> + level</span><br><span class="line">        ]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(track_indices_l) == <span class="number">0</span>:  <span class="comment"># Nothing to match at this level</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2. 级联匹配核心内容就是这个函数</span></span><br><span class="line">        matches_l, _, unmatched_detections = \</span><br><span class="line">            min_cost_matching(  <span class="comment"># max_distance=0.2</span></span><br><span class="line">                distance_metric, max_distance, tracks, detections,</span><br><span class="line">                track_indices_l, unmatched_detections)</span><br><span class="line">        matches += matches_l</span><br><span class="line">    unmatched_tracks = <span class="built_in">list</span>(<span class="built_in">set</span>(track_indices) - <span class="built_in">set</span>(k <span class="keyword">for</span> k, _ <span class="keyword">in</span> matches))</span><br><span class="line">    <span class="keyword">return</span> matches, unmatched_tracks, unmatched_detections</span><br></pre></td></tr></table></figure>
<p>可以看到和伪代码是一致的，文章上半部分也有提到这部分代码。这部分代码中还有一个核心的函数 min_cost_matching，这个函数可以接收不同的 distance_metric，在级联匹配和 IoU 匹配中都有用到。</p>
<p>min_cost_matching 函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">min_cost_matching</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        distance_metric, max_distance, tracks, detections, track_indices=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        detection_indices=<span class="literal">None</span></span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> track_indices <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        track_indices = np.arange(<span class="built_in">len</span>(tracks))</span><br><span class="line">    <span class="keyword">if</span> detection_indices <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        detection_indices = np.arange(<span class="built_in">len</span>(detections))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(detection_indices) == <span class="number">0</span> <span class="keyword">or</span> <span class="built_in">len</span>(track_indices) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> [], track_indices, detection_indices  <span class="comment"># Nothing to match.</span></span><br><span class="line">    <span class="comment"># -----------------------------------------</span></span><br><span class="line">    <span class="comment"># Gated_distance——&gt;</span></span><br><span class="line">    <span class="comment">#       1. cosine distance</span></span><br><span class="line">    <span class="comment">#       2. 马氏距离</span></span><br><span class="line">    <span class="comment"># 得到代价矩阵</span></span><br><span class="line">    <span class="comment"># -----------------------------------------</span></span><br><span class="line">    <span class="comment"># iou_cost——&gt;</span></span><br><span class="line">    <span class="comment">#       仅仅计算track和detection之间的iou距离</span></span><br><span class="line">    <span class="comment"># -----------------------------------------</span></span><br><span class="line">    cost_matrix = distance_metric(</span><br><span class="line">        tracks, detections, track_indices, detection_indices)</span><br><span class="line">    <span class="comment"># -----------------------------------------</span></span><br><span class="line">    <span class="comment"># gated_distance中设置距离中最高上限，</span></span><br><span class="line">    <span class="comment"># 这里最远距离实际是在deep sort类中的max_dist参数设置的</span></span><br><span class="line">    <span class="comment"># 默认max_dist=0.2， 距离越小越好</span></span><br><span class="line">    <span class="comment"># -----------------------------------------</span></span><br><span class="line">    <span class="comment"># iou_cost情况下，max_distance的设置对应tracker中的max_iou_distance,</span></span><br><span class="line">    <span class="comment"># 默认值为max_iou_distance=0.7</span></span><br><span class="line">    <span class="comment"># 注意结果是1-iou，所以越小越好</span></span><br><span class="line">    <span class="comment"># -----------------------------------------</span></span><br><span class="line">    cost_matrix[cost_matrix &gt; max_distance] = max_distance + <span class="number">1e-5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 匈牙利算法或者KM算法</span></span><br><span class="line">    row_indices, col_indices = linear_assignment(cost_matrix)</span><br><span class="line"></span><br><span class="line">    matches, unmatched_tracks, unmatched_detections = [], [], []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这几个for循环用于对匹配结果进行筛选，得到匹配和未匹配的结果</span></span><br><span class="line">    <span class="keyword">for</span> col, detection_idx <span class="keyword">in</span> <span class="built_in">enumerate</span>(detection_indices):</span><br><span class="line">        <span class="keyword">if</span> col <span class="keyword">not</span> <span class="keyword">in</span> col_indices:</span><br><span class="line">            unmatched_detections.append(detection_idx)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> row, track_idx <span class="keyword">in</span> <span class="built_in">enumerate</span>(track_indices):</span><br><span class="line">        <span class="keyword">if</span> row <span class="keyword">not</span> <span class="keyword">in</span> row_indices:</span><br><span class="line">            unmatched_tracks.append(track_idx)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> row, col <span class="keyword">in</span> <span class="built_in">zip</span>(row_indices, col_indices):</span><br><span class="line">        track_idx = track_indices[row]</span><br><span class="line">        detection_idx = detection_indices[col]</span><br><span class="line">        <span class="keyword">if</span> cost_matrix[row, col] &gt; max_distance:</span><br><span class="line">            unmatched_tracks.append(track_idx)</span><br><span class="line">            unmatched_detections.append(detection_idx)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            matches.append((track_idx, detection_idx))</span><br><span class="line">    <span class="comment"># 得到匹配，未匹配轨迹，未匹配检测</span></span><br><span class="line">    <span class="keyword">return</span> matches, unmatched_tracks, unmatched_detections</span><br></pre></td></tr></table></figure>
<p>注释中提到 distance_metric 是有两个的：</p>
<ul>
<li>第一个是级联匹配中传入的 distance_metric 是 gated_metric, 其内部核心是计算的表观特征的级联匹配。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gated_metric</span>(<span class="params">tracks, dets, track_indices, detection_indices</span>):</span></span><br><span class="line">    <span class="comment"># 功能： 用于计算track和detection之间的距离，代价函数</span></span><br><span class="line">    <span class="comment">#        需要使用在KM算法之前</span></span><br><span class="line">    <span class="comment"># 调用：</span></span><br><span class="line">    <span class="comment"># cost_matrix = distance_metric(tracks, detections,</span></span><br><span class="line">    <span class="comment">#                  track_indices, detection_indices)</span></span><br><span class="line">    features = np.array([dets[i].feature <span class="keyword">for</span> i <span class="keyword">in</span> detection_indices])</span><br><span class="line">    targets = np.array([tracks[i].track_id <span class="keyword">for</span> i <span class="keyword">in</span> track_indices])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. 通过最近邻计算出代价矩阵 cosine distance</span></span><br><span class="line">    cost_matrix = self.metric.distance(features, targets)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 计算马氏距离,得到新的状态矩阵</span></span><br><span class="line">    cost_matrix = linear_assignment.gate_cost_matrix(</span><br><span class="line">        self.kf, cost_matrix, tracks, dets, track_indices,</span><br><span class="line">        detection_indices)</span><br><span class="line">    <span class="keyword">return</span> cost_matrix</span><br></pre></td></tr></table></figure>
<p>对应下图进行理解 (下图上半部分就是对应的 gated_metric 函数)：</p>
<center><img src="https://pic4.zhimg.com/80/v2-ad78b882e0a502e8459c2adf6792a7a3_1440w.jpg" alt="img" style="zoom: 45%;"></center>
<ul>
<li>第二个是 IOU 匹配中的 iou_matching.iou_cost:</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 虽然和级联匹配中使用的都是min_cost_matching作为核心，</span></span><br><span class="line"><span class="comment"># 这里使用的metric是iou cost和以上不同</span></span><br><span class="line">matches_b, unmatched_tracks_b, unmatched_detections = \</span><br><span class="line">    linear_assignment.min_cost_matching(</span><br><span class="line">        iou_matching.iou_cost,</span><br><span class="line">        self.max_iou_distance,</span><br><span class="line">        self.tracks,</span><br><span class="line">        detections,</span><br><span class="line">        iou_track_candidates,</span><br><span class="line">        unmatched_detections)</span><br></pre></td></tr></table></figure>
<p>iou_cost 代价很容易理解，用于计算 Track 和 Detection 之间的 IOU 距离矩阵。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">iou_cost</span>(<span class="params">tracks, detections, track_indices=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">             detection_indices=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="comment"># 计算track和detection之间的iou距离矩阵</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> track_indices <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        track_indices = np.arange(<span class="built_in">len</span>(tracks))</span><br><span class="line">    <span class="keyword">if</span> detection_indices <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        detection_indices = np.arange(<span class="built_in">len</span>(detections))</span><br><span class="line"></span><br><span class="line">    cost_matrix = np.zeros((<span class="built_in">len</span>(track_indices), <span class="built_in">len</span>(detection_indices)))</span><br><span class="line">    <span class="keyword">for</span> row, track_idx <span class="keyword">in</span> <span class="built_in">enumerate</span>(track_indices):</span><br><span class="line">        <span class="keyword">if</span> tracks[track_idx].time_since_update &gt; <span class="number">1</span>:</span><br><span class="line">            cost_matrix[row, :] = linear_assignment.INFTY_COST</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        bbox = tracks[track_idx].to_tlwh()</span><br><span class="line">        candidates = np.asarray(</span><br><span class="line">            [detections[i].tlwh <span class="keyword">for</span> i <span class="keyword">in</span> detection_indices])</span><br><span class="line">        cost_matrix[row, :] = <span class="number">1.</span> - iou(bbox, candidates)</span><br><span class="line">    <span class="keyword">return</span> cost_matrix</span><br></pre></td></tr></table></figure>
<h4><span id="6-总结"> 6. 总结</span></h4>
<p>以上就是 Deep SORT 算法代码部分的解析，核心在于类图和流程图，理解 Deep SORT 实现的过程。</p>
<p>如果第一次接触到多目标跟踪算法领域的，可以到知乎上看这篇文章以及其系列，对新手非常友好： <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/62827974">https://zhuanlan.zhihu.com/p/62827974</a></p>
<p>笔者也收集了一些多目标跟踪领域中认可度比较高、常见的库，在这里分享给大家：</p>
<ul>
<li>SORT 官方代码： <a href="https://link.zhihu.com/?target=https%3A//github.com/abewley/sort">https://github.com/abewley/sort</a></li>
<li>DeepSORT 官方代码： <a href="https://link.zhihu.com/?target=https%3A//github.com/nwojke/deep_sort">https://github.com/nwojke/deep_sort</a></li>
<li>奇点大佬 keras 实现 DeepSORT: <a href="https://link.zhihu.com/?target=https%3A//github.com/Qidian213/deep_sort_yolov3">https://github.com/Qidian213/deep_sort_yolov3</a></li>
<li>CenterNet 作检测器的 DeepSORT: <a href="https://link.zhihu.com/?target=https%3A//github.com/xingyizhou/CenterTrack">https://github.com/xingyizhou/CenterTrack</a> 和 <a href="https://link.zhihu.com/?target=https%3A//github.com/kimyoon-young/centerNet-deep-sort">https://github.com/kimyoon-young/centerNet-deep-sort</a></li>
<li>JDE Github 地址: <a href="https://link.zhihu.com/?target=https%3A//github.com/Zhongdao/Towards-Realtime-MOT">https://github.com/Zhongdao/Towards-Realtime-MOT</a></li>
<li>FairMOT Github 地址: <a href="https://link.zhihu.com/?target=https%3A//github.com/ifzhang/FairMOT">https://github.com/ifzhang/FairMOT</a></li>
<li>笔者修改的代码： <a href="https://link.zhihu.com/?target=https%3A//github.com/pprp/deep_sort_yolov3_pytorch">https://github.com/pprp/deep_sort_yolov3_pytorch</a></li>
</ul>
<p>笔者也是最近一段时间接触目标跟踪领域，数学水平非常有限 (卡尔曼滤波只能肤浅了解大概过程，但是还不会推导)。本文目标就是帮助新入门多目标跟踪的新人快速了解 Deep SORT 流程，由于自身水平有限，也欢迎大佬对文中不足之处进行指点一二。</p>

            <div class="post-copyright">
    <div class="content">
        <p>最后更新： 2021年08月28日 20:57</p>
        <p>原始链接： <a class="post-url" href="/2021/08/28/Deep-SORT%E5%A4%9A%E7%9B%AE%E6%A0%87%E8%B7%9F%E8%B8%AA%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/" title="Deep SORT多目标跟踪算法代码解析">https://leezhao415.github.io/2021/08/28/Deep-SORT%E5%A4%9A%E7%9B%AE%E6%A0%87%E8%B7%9F%E8%B8%AA%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/</a></p>
        <footer>
            <a href="https://leezhao415.github.io">
                <img src="/images/logo.jpg" alt="LeeZhao">
                LeeZhao
            </a>
        </footer>
    </div>
</div>

      
        
            
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;">赏</a>
</div>

<div id="reward" class="post-modal reward-lay">
    <a class="close" href="javascript:;" id="reward-close">×</a>
    <span class="reward-title">
        <i class="icon icon-quote-left"></i>
        请我吃糖~
        <i class="icon icon-quote-right"></i>
    </span>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/images/wechat_code.jpg" alt="打赏二维码">
        </div>
        <div class="reward-select">
            
            <label class="reward-select-item checked" data-id="wechat" data-wechat="/images/wechat_code.jpg">
                <img class="reward-select-item-wechat" src="/images/wechat.png" alt="微信">
            </label>
            
            
            <label class="reward-select-item" data-id="alipay" data-alipay="/images/alipay_code.jpg">
                <img class="reward-select-item-alipay" src="/images/alipay.png" alt="支付宝">
            </label>
            
        </div>
    </div>
</div>


        
    </div>
    <footer class="article-footer">
        
        
<div class="post-share">
    <a href="javascript:;" id="share-sub" class="post-share-fab">
        <i class="fa fa-share-alt"></i>
    </a>
    <div class="post-share-list" id="share-list">
        <ul class="share-icons">
          <li>
            <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://leezhao415.github.io/2021/08/28/Deep-SORT%E5%A4%9A%E7%9B%AE%E6%A0%87%E8%B7%9F%E8%B8%AA%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/&title=《Deep SORT多目标跟踪算法代码解析》 — 且听风吟，御剑于心！&pic=images/DeepSORT.jpg" data-title="微博">
              <i class="fa fa-weibo"></i>
            </a>
          </li>
          <li>
            <a class="weixin share-sns" id="wxFab" href="javascript:;" data-title="微信">
              <i class="fa fa-weixin"></i>
            </a>
          </li>
          <li>
            <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://leezhao415.github.io/2021/08/28/Deep-SORT%E5%A4%9A%E7%9B%AE%E6%A0%87%E8%B7%9F%E8%B8%AA%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/&title=《Deep SORT多目标跟踪算法代码解析》 — 且听风吟，御剑于心！&source=" data-title="QQ">
              <i class="fa fa-qq"></i>
            </a>
          </li>
          <li>
            <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://leezhao415.github.io/2021/08/28/Deep-SORT%E5%A4%9A%E7%9B%AE%E6%A0%87%E8%B7%9F%E8%B8%AA%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/" data-title="Facebook">
              <i class="fa fa-facebook"></i>
            </a>
          </li>
          <li>
            <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Deep SORT多目标跟踪算法代码解析》 — 且听风吟，御剑于心！&url=https://leezhao415.github.io/2021/08/28/Deep-SORT%E5%A4%9A%E7%9B%AE%E6%A0%87%E8%B7%9F%E8%B8%AA%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/&via=https://leezhao415.github.io" data-title="Twitter">
              <i class="fa fa-twitter"></i>
            </a>
          </li>
          <li>
            <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://leezhao415.github.io/2021/08/28/Deep-SORT%E5%A4%9A%E7%9B%AE%E6%A0%87%E8%B7%9F%E8%B8%AA%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/" data-title="Google+">
              <i class="fa fa-google-plus"></i>
            </a>
          </li>
        </ul>
     </div>
</div>
<div class="post-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;" id="wxShare-close">×</a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=https://leezhao415.github.io/2021/08/28/Deep-SORT%E5%A4%9A%E7%9B%AE%E6%A0%87%E8%B7%9F%E8%B8%AA%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/" alt="微信分享二维码">
</div>

<div class="mask"></div>

        
        <ul class="article-footer-menu">
            
            
  <li class="article-footer-tags">
    <i class="fa fa-tags"></i>
      
    <a href="/tags/人工智能/" class="color5">人工智能</a>
      
    <a href="/tags/MOT/" class="color4">MOT</a>
      
  </li>

        </ul>
        
    </footer>
  </div>
</article>


    <aside class="post-toc-pos post-toc-top" id="post-toc">
        <nav class="post-toc-wrap">
            <ol class="post-toc"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link"><span class="post-toc-text"> Deep SORT 多目标跟踪算法代码解析</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link"><span class="post-toc-text"> 1. MOT 主要步骤</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link"><span class="post-toc-text"> 2. SORT</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link"><span class="post-toc-text"> 3. Deep SORT</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link"><span class="post-toc-text"> 4. Deep SORT 代码解析</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link"><span class="post-toc-text"> 4.1 类图</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link"><span class="post-toc-text"> 4.2 核心模块</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link"><span class="post-toc-text"> Detection 类</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link"><span class="post-toc-text"> Track 类</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link"><span class="post-toc-text"> ReID 特征提取部分</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link"><span class="post-toc-text"> NearestNeighborDistanceMetric 类</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link"><span class="post-toc-text"> 最近邻距离度量类</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link"><span class="post-toc-text"> Tracker 类</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link"><span class="post-toc-text"> 级联匹配</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link"><span class="post-toc-text"> 门控矩阵</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link"><span class="post-toc-text"> 卡尔曼滤波器</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link"><span class="post-toc-text"> 5. 流程解析</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link"><span class="post-toc-text"> 6. 总结</span></a></li></ol></li></ol>
        </nav>
    </aside>
    

<nav id="article-nav">
  
    <a href="/2021/09/12/%E3%80%90%E7%B2%BE%E5%8D%8E%E3%80%91%E7%AE%97%E6%B3%95%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/" id="article-nav-newer" class="article-nav-link-wrap">

      <span class="article-nav-title">
        <i class="fa fa-hand-o-left" aria-hidden="true"></i>
        
          【精华】算法工程师技术学习路线
        
      </span>
    </a>
  
  
    <a href="/2021/08/28/%E3%80%90%E8%AF%A6%E8%A7%A3%E3%80%91IoU%E3%80%81GIoU%E3%80%81DIoU%E3%80%81CIoU%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/" id="article-nav-older" class="article-nav-link-wrap">
      <span class="article-nav-title">【详解】IoU、GIoU、DIoU、CIoU损失函数</span>
      <i class="fa fa-hand-o-right" aria-hidden="true"></i>
    </a>
  
</nav>



    
        <div id="SOHUCS" sid="Deep-SORT多目标跟踪算法代码解析" ></div>
<script type="text/javascript">
    (function(){
        var appid = 'true';
        var conf = 'true';
        var width = window.innerWidth || document.documentElement.clientWidth;
        if (width < 960) {
            window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>'); } else { var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); </script>
    
</section>
        
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info" class="inner">
      
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


      <p>
        Powered by  <a href="http://hexo.io/" target="_blank">Hexo</a>
        Theme <a href="//github.com/wongminho/hexo-theme-miho" target="_blank">MiHo</a>
      &copy; 2024 LeeZhao<br>
      </p>
    </div>
  </div>
</footer>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<script>
  var mihoConfig = {
      root: "https://leezhao415.github.io",
      animate: true,
      isHome: false,
      share: true,
      reward: 1
  }
</script>
<div class="sidebar">
    <div id="sidebar-search" title="Search">
        <i class="fa fa-search"></i>
    </div>
    <div id="sidebar-category" title="Categories">
        <i class="fa fa-book"></i>
    </div>
    <div id="sidebar-tag" title="Tags">
        <i class="fa fa-tags"></i>
    </div>
    <div id="sidebar-top">
        <span class="sidebar-top-icon"><i class="fa fa-angle-up"></i></span>
    </div>
</div>
<div class="sidebar-menu-box" id="sidebar-menu-box">
    <div class="sidebar-menu-box-container">
        <div id="sidebar-menu-box-categories">
            <a class="category-link" href="/categories/Hot/">Hot</a>
        </div>
        <div id="sidebar-menu-box-tags">
            <a href="/tags/AIGC%E5%89%8D%E6%B2%BF/" style="font-size: 10px;">AIGC前沿</a> <a href="/tags/CV-%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%E7%AE%B1/" style="font-size: 10px;">CV/目标检测工具箱</a> <a href="/tags/CV%E6%95%B0%E6%8D%AE%E9%9B%86/" style="font-size: 10px;">CV数据集</a> <a href="/tags/CV%E6%9C%AA%E6%9D%A5/" style="font-size: 10px;">CV未来</a> <a href="/tags/CV%E7%AE%97%E6%B3%95/" style="font-size: 10px;">CV算法</a> <a href="/tags/IOU/" style="font-size: 10px;">IOU</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/MOT/" style="font-size: 10px;">MOT</a> <a href="/tags/NCNN%E9%83%A8%E7%BD%B2/" style="font-size: 10px;">NCNN部署</a> <a href="/tags/NLP/" style="font-size: 15px;">NLP</a> <a href="/tags/NLP-BERT/" style="font-size: 10px;">NLP-BERT</a> <a href="/tags/NLP-%E5%8F%91%E5%B1%95%E5%8F%B2/" style="font-size: 10px;">NLP-发展史</a> <a href="/tags/NLP-%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8C%96/" style="font-size: 10px;">NLP-模型优化</a> <a href="/tags/NLP-%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%BC%BA%E5%B7%A5%E5%85%B7/" style="font-size: 10px;">NLP/数据增强工具</a> <a href="/tags/NLP-%E8%AF%84%E4%BC%B0%E6%8C%87%E6%A0%87/" style="font-size: 10px;">NLP/评估指标</a> <a href="/tags/OpenCV%E4%B9%8BDNN%E6%A8%A1%E5%9D%97/" style="font-size: 10px;">OpenCV之DNN模块</a> <a href="/tags/PaddlePaddle/" style="font-size: 10px;">PaddlePaddle</a> <a href="/tags/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/" style="font-size: 10px;">Python数据分析</a> <a href="/tags/ReID/" style="font-size: 10px;">ReID</a> <a href="/tags/Transformer-DETR-CV/" style="font-size: 10px;">Transformer/DETR(CV)</a> <a href="/tags/VSLAM/" style="font-size: 11.67px;">VSLAM</a> <a href="/tags/YOLOX/" style="font-size: 10px;">YOLOX</a> <a href="/tags/YOLOX%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/" style="font-size: 11.67px;">YOLOX目标检测</a> <a href="/tags/%E4%B8%89%E7%BB%B4%E5%BB%BA%E6%A8%A1/" style="font-size: 10px;">三维建模</a> <a href="/tags/%E4%B8%94%E8%AF%BB%E6%96%87%E6%91%98/" style="font-size: 13.33px;">且读文摘</a> <a href="/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/" style="font-size: 20px;">人工智能</a> <a href="/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD-CV/" style="font-size: 10px;">人工智能/CV</a> <a href="/tags/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/" style="font-size: 10px;">人脸识别</a> <a href="/tags/%E5%90%8D%E4%BA%BA%E5%90%8D%E8%A8%80/" style="font-size: 10px;">名人名言</a> <a href="/tags/%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B/" style="font-size: 10px;">多任务学习模型</a> <a href="/tags/%E5%A4%9A%E6%A8%A1%E6%80%81/" style="font-size: 11.67px;">多模态</a> <a href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%A1%86%E6%9E%B6/" style="font-size: 10px;">大数据框架</a> <a href="/tags/%E5%AF%92%E7%AA%91%E8%B5%8B/" style="font-size: 10px;">寒窑赋</a> <a href="/tags/%E5%BA%A6%E9%87%8F%E5%AD%A6%E4%B9%A0/" style="font-size: 10px;">度量学习</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 10px;">操作系统</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/" style="font-size: 10px;">数据库原理</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" style="font-size: 11.67px;">数据结构与算法</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E9%9B%86/" style="font-size: 11.67px;">数据集</a> <a href="/tags/%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85/" style="font-size: 10px;">智能家居</a> <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 10px;">机器学习</a> <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/" style="font-size: 10px;">机器学习/损失函数</a> <a href="/tags/%E6%A2%AF%E5%BA%A6%E6%9B%B4%E6%96%B0/" style="font-size: 10px;">梯度更新</a> <a href="/tags/%E6%A6%82%E8%BF%B0/" style="font-size: 10px;">概述</a> <a href="/tags/%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8C%96/" style="font-size: 10px;">模型优化</a> <a href="/tags/%E6%A8%A1%E5%9E%8B%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/" style="font-size: 10px;">模型性能指标</a> <a href="/tags/%E6%A8%A1%E5%9E%8B%E9%83%A8%E7%BD%B2/" style="font-size: 16.67px;">模型部署</a> <a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" style="font-size: 10px;">深度学习</a> <a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" style="font-size: 10px;">深度学习环境配置</a> <a href="/tags/%E6%B7%B1%E5%BA%A6%E6%A8%A1%E5%9E%8B/" style="font-size: 10px;">深度模型</a> <a href="/tags/%E6%B7%B1%E5%BA%A6%E6%A8%A1%E5%9E%8B%EF%BC%88%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%EF%BC%89/" style="font-size: 10px;">深度模型（目标检测）</a> <a href="/tags/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/" style="font-size: 10px;">激活函数</a> <a href="/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%EF%BC%88%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B%EF%BC%89/" style="font-size: 10px;">目标检测（人脸检测）</a> <a href="/tags/%E7%9B%AE%E6%A0%87%E8%B7%9F%E8%B8%AA/" style="font-size: 10px;">目标跟踪</a> <a href="/tags/%E7%9F%A5%E8%AF%86%E8%92%B8%E9%A6%8F/" style="font-size: 10px;">知识蒸馏</a> <a href="/tags/%E7%A7%91%E7%A0%94%E9%A1%B9%E7%9B%AE%E6%88%90%E6%9E%9C/" style="font-size: 10px;">科研项目成果</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 11.67px;">算法</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/" style="font-size: 18.33px;">编程工具</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" style="font-size: 10px;">编程语言</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" style="font-size: 10px;">网络编程</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/" style="font-size: 10px;">网络通信</a> <a href="/tags/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86NLP/" style="font-size: 10px;">自然语言处理NLP</a> <a href="/tags/%E8%A1%A8%E9%9D%A2%E7%BC%BA%E9%99%B7%E6%A3%80%E6%B5%8B/" style="font-size: 10px;">表面缺陷检测</a> <a href="/tags/%E8%A7%86%E9%A2%91%E7%90%86%E8%A7%A3/" style="font-size: 10px;">视频理解</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/" style="font-size: 10px;">计算机视觉</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89CV/" style="font-size: 15px;">计算机视觉CV</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%BA%93/" style="font-size: 10px;">计算机视觉库</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%A1%B6%E4%BC%9A/" style="font-size: 10px;">计算机顶会</a>
        </div>
    </div>
    <a href="javascript:;" class="sidebar-menu-box-close">&times;</a>
</div>
<div class="mobile-header-menu-nav" id="mobile-header-menu-nav">
    <div class="mobile-header-menu-container">
        <span class="title">Menus</span>
        <ul class="mobile-header-menu-navbar">
            
            <li>
                <a  href="/">
                    <i class="fa fa-home"></i><span>Home</span>
                </a>
            </li>
            
            <li>
                <a  href="/archives">
                    <i class="fa fa-archive"></i><span>Archives</span>
                </a>
            </li>
            
            <li>
                <a  href="/about">
                    <i class="fa fa-user"></i><span>About</span>
                </a>
            </li>
            
        </ul>
    </div>
    <div class="mobile-header-tag-container">
        <span class="title">Tags</span>
        <div id="mobile-header-container-tags">
            <a href="/tags/AIGC%E5%89%8D%E6%B2%BF/" style="font-size: 10px;">AIGC前沿</a> <a href="/tags/CV-%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%E7%AE%B1/" style="font-size: 10px;">CV/目标检测工具箱</a> <a href="/tags/CV%E6%95%B0%E6%8D%AE%E9%9B%86/" style="font-size: 10px;">CV数据集</a> <a href="/tags/CV%E6%9C%AA%E6%9D%A5/" style="font-size: 10px;">CV未来</a> <a href="/tags/CV%E7%AE%97%E6%B3%95/" style="font-size: 10px;">CV算法</a> <a href="/tags/IOU/" style="font-size: 10px;">IOU</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/MOT/" style="font-size: 10px;">MOT</a> <a href="/tags/NCNN%E9%83%A8%E7%BD%B2/" style="font-size: 10px;">NCNN部署</a> <a href="/tags/NLP/" style="font-size: 15px;">NLP</a> <a href="/tags/NLP-BERT/" style="font-size: 10px;">NLP-BERT</a> <a href="/tags/NLP-%E5%8F%91%E5%B1%95%E5%8F%B2/" style="font-size: 10px;">NLP-发展史</a> <a href="/tags/NLP-%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8C%96/" style="font-size: 10px;">NLP-模型优化</a> <a href="/tags/NLP-%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%BC%BA%E5%B7%A5%E5%85%B7/" style="font-size: 10px;">NLP/数据增强工具</a> <a href="/tags/NLP-%E8%AF%84%E4%BC%B0%E6%8C%87%E6%A0%87/" style="font-size: 10px;">NLP/评估指标</a> <a href="/tags/OpenCV%E4%B9%8BDNN%E6%A8%A1%E5%9D%97/" style="font-size: 10px;">OpenCV之DNN模块</a> <a href="/tags/PaddlePaddle/" style="font-size: 10px;">PaddlePaddle</a> <a href="/tags/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/" style="font-size: 10px;">Python数据分析</a> <a href="/tags/ReID/" style="font-size: 10px;">ReID</a> <a href="/tags/Transformer-DETR-CV/" style="font-size: 10px;">Transformer/DETR(CV)</a> <a href="/tags/VSLAM/" style="font-size: 11.67px;">VSLAM</a> <a href="/tags/YOLOX/" style="font-size: 10px;">YOLOX</a> <a href="/tags/YOLOX%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/" style="font-size: 11.67px;">YOLOX目标检测</a> <a href="/tags/%E4%B8%89%E7%BB%B4%E5%BB%BA%E6%A8%A1/" style="font-size: 10px;">三维建模</a> <a href="/tags/%E4%B8%94%E8%AF%BB%E6%96%87%E6%91%98/" style="font-size: 13.33px;">且读文摘</a> <a href="/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/" style="font-size: 20px;">人工智能</a> <a href="/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD-CV/" style="font-size: 10px;">人工智能/CV</a> <a href="/tags/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/" style="font-size: 10px;">人脸识别</a> <a href="/tags/%E5%90%8D%E4%BA%BA%E5%90%8D%E8%A8%80/" style="font-size: 10px;">名人名言</a> <a href="/tags/%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B/" style="font-size: 10px;">多任务学习模型</a> <a href="/tags/%E5%A4%9A%E6%A8%A1%E6%80%81/" style="font-size: 11.67px;">多模态</a> <a href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%A1%86%E6%9E%B6/" style="font-size: 10px;">大数据框架</a> <a href="/tags/%E5%AF%92%E7%AA%91%E8%B5%8B/" style="font-size: 10px;">寒窑赋</a> <a href="/tags/%E5%BA%A6%E9%87%8F%E5%AD%A6%E4%B9%A0/" style="font-size: 10px;">度量学习</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 10px;">操作系统</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/" style="font-size: 10px;">数据库原理</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" style="font-size: 11.67px;">数据结构与算法</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E9%9B%86/" style="font-size: 11.67px;">数据集</a> <a href="/tags/%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85/" style="font-size: 10px;">智能家居</a> <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 10px;">机器学习</a> <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/" style="font-size: 10px;">机器学习/损失函数</a> <a href="/tags/%E6%A2%AF%E5%BA%A6%E6%9B%B4%E6%96%B0/" style="font-size: 10px;">梯度更新</a> <a href="/tags/%E6%A6%82%E8%BF%B0/" style="font-size: 10px;">概述</a> <a href="/tags/%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8C%96/" style="font-size: 10px;">模型优化</a> <a href="/tags/%E6%A8%A1%E5%9E%8B%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/" style="font-size: 10px;">模型性能指标</a> <a href="/tags/%E6%A8%A1%E5%9E%8B%E9%83%A8%E7%BD%B2/" style="font-size: 16.67px;">模型部署</a> <a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" style="font-size: 10px;">深度学习</a> <a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" style="font-size: 10px;">深度学习环境配置</a> <a href="/tags/%E6%B7%B1%E5%BA%A6%E6%A8%A1%E5%9E%8B/" style="font-size: 10px;">深度模型</a> <a href="/tags/%E6%B7%B1%E5%BA%A6%E6%A8%A1%E5%9E%8B%EF%BC%88%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%EF%BC%89/" style="font-size: 10px;">深度模型（目标检测）</a> <a href="/tags/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/" style="font-size: 10px;">激活函数</a> <a href="/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%EF%BC%88%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B%EF%BC%89/" style="font-size: 10px;">目标检测（人脸检测）</a> <a href="/tags/%E7%9B%AE%E6%A0%87%E8%B7%9F%E8%B8%AA/" style="font-size: 10px;">目标跟踪</a> <a href="/tags/%E7%9F%A5%E8%AF%86%E8%92%B8%E9%A6%8F/" style="font-size: 10px;">知识蒸馏</a> <a href="/tags/%E7%A7%91%E7%A0%94%E9%A1%B9%E7%9B%AE%E6%88%90%E6%9E%9C/" style="font-size: 10px;">科研项目成果</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 11.67px;">算法</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/" style="font-size: 18.33px;">编程工具</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" style="font-size: 10px;">编程语言</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" style="font-size: 10px;">网络编程</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/" style="font-size: 10px;">网络通信</a> <a href="/tags/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86NLP/" style="font-size: 10px;">自然语言处理NLP</a> <a href="/tags/%E8%A1%A8%E9%9D%A2%E7%BC%BA%E9%99%B7%E6%A3%80%E6%B5%8B/" style="font-size: 10px;">表面缺陷检测</a> <a href="/tags/%E8%A7%86%E9%A2%91%E7%90%86%E8%A7%A3/" style="font-size: 10px;">视频理解</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/" style="font-size: 10px;">计算机视觉</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89CV/" style="font-size: 15px;">计算机视觉CV</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%BA%93/" style="font-size: 10px;">计算机视觉库</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%A1%B6%E4%BC%9A/" style="font-size: 10px;">计算机顶会</a>
        </div>
    </div>
</div>
<div class="search-wrap">
    <span class="search-close">&times;</span>
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
            <i class="icon icon-lg icon-chevron-left"></i>
        </a>
        <input class="search-field" placeholder="Search..." id="keywords">
        <a id="search-submit" href="javascript:;">
            <i class="fa fa-search"></i>
        </a>
    <div class="search-container" id="search-container">
        <ul class="search-result" id="search-result">
        </ul>
    </div>
</div>

<div id="search-tpl">
    <li class="search-result-item">
        <a href="{url}" class="search-item-li">
            <span class="search-item-li-title" title="{title}">{title}</span>
        </a>
    </li>
</div>

<script src="/js/search.js"></script>


<script src="/js/main.js"></script>



  <script src="//cdn.bootcss.com/particles.js/2.0.0/particles.min.js"></script>
  <div id="particles"></div>
  
<script src="/js/particles.js"></script>








  
<link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">

  <script src="//cdn.bootcss.com/scrollReveal.js/3.0.5/scrollreveal.js"></script>
  
<script src="/js/animate.js"></script>



  
<script src="/js/pop-img.js"></script>

  <script>
     $(".article-entry p img").popImg();
  </script>

  </div>
</body>
</html>
{
    "version": "https://jsonfeed.org/version/1",
    "title": "且听风吟，御剑于心！ • All posts by \"nlp-bert\" tag",
    "description": "",
    "home_page_url": "https://leezhao415.github.io",
    "items": [
        {
            "id": "https://leezhao415.github.io/2021/07/09/%E3%80%90%E8%AF%A6%E8%A7%A3%E3%80%91BERT%E7%9A%843%E4%B8%AAEmbedding%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/",
            "url": "https://leezhao415.github.io/2021/07/09/%E3%80%90%E8%AF%A6%E8%A7%A3%E3%80%91BERT%E7%9A%843%E4%B8%AAEmbedding%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/",
            "title": "【详解】BERT的3个Embedding的实现原理",
            "date_published": "2021-07-09T11:32:40.000Z",
            "content_html": "<meta name=\"referrer\" content=\"no-referrer\">\n<hr>\n<p><strong>文章目录</strong></p>\n<!-- toc -->\n<ul>\n<li><a href=\"#%E6%A6%82%E8%A7%88\">概览</a></li>\n<li><a href=\"#1-token-embeddings\">1 Token Embeddings</a>\n<ul>\n<li><a href=\"#%E4%BD%9C%E7%94%A8\">作用</a></li>\n<li><a href=\"#%E5%AE%9E%E7%8E%B0\">实现</a></li>\n</ul>\n</li>\n<li><a href=\"#2-segment-embeddings\">2 Segment Embeddings</a>\n<ul>\n<li><a href=\"#%E4%BD%9C%E7%94%A8-1\">作用</a></li>\n<li><a href=\"#%E5%AE%9E%E7%8E%B0-1\">实现</a></li>\n</ul>\n</li>\n<li><a href=\"#3-position-embeddings\">3 Position Embeddings</a>\n<ul>\n<li><a href=\"#%E4%BD%9C%E7%94%A8-2\">作用</a></li>\n<li><a href=\"#%E5%AE%9E%E7%8E%B0-2\">实现</a></li>\n</ul>\n</li>\n<li><a href=\"#4-%E5%90%88%E6%88%90%E8%A1%A8%E7%A4%BA\">4 合成表示</a></li>\n</ul>\n<!-- tocstop -->\n<hr>\n<p>本文将阐述 BERT 中嵌入层的实现细节，包括 token embeddings、segment embeddings, 和 position embeddings.</p>\n<h3><span id=\"概览\"> 概览</span></h3>\n<p>下面这幅来自原论文的图清晰地展示了 BERT 中每一个嵌入层的作用：</p>\n<center><img src=\"https://img-blog.csdnimg.cn/20210709191935205.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzIyODg3,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\" style=\"zoom: 67%;\"></center>\n<p>和大多数 NLP 深度学习模型一样，BERT 将输入文本中的每一个词（token) 送入 token embedding 层从而将每一个词转换成向量形式。但不同于其他模型的是，BERT 又多了两个嵌入层，即 segment embeddings 和 position embeddings。在阅读完本文之后，你就会明白为何要多加这两个嵌入层了。</p>\n<h3><span id=\"1-token-embeddings\"> 1 Token Embeddings</span></h3>\n<h4><span id=\"作用\"> 作用</span></h4>\n<p>正如前面提到的，token embedding 层是要将各个词转换成固定维度的向量。在 BERT 中，每个词会被转换成 768 维的向量表示。</p>\n<h4><span id=\"实现\"> 实现</span></h4>\n<p>假设输入文本是 “I like strawberries”。下面这个图展示了 Token Embeddings 层的实现过程:</p>\n<center><img src=\"https://img-blog.csdnimg.cn/20210709191953310.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzIyODg3,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\" style=\"zoom: 60%;\"></center>\n<p>输入文本在送入 token embeddings 层之前要先进行 tokenization 处理。此外，两个特殊的 token 会被插入到 tokenization 的结果的开头 ([CLS]) 和结尾 ([SEP]) 。它们视为后面的分类任务和划分句子对服务的。</p>\n<p>tokenization 使用的方法是 WordPiece tokenization. 这是一个数据驱动式的 tokenization 方法，旨在权衡词典大小和 oov 词的个数。这种方法把例子中的 “strawberries” 切分成了 “straw” 和 “berries”。这种方法的详细内容不在本文的范围内。有兴趣的读者可以参阅 <a href=\"https://arxiv.org/pdf/1609.08144.pdf\">Wu et al. (2016)</a> 和 <a href=\"https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/37842.pdf\">Schuster &amp; Nakajima (2012)</a>。使用 WordPiece tokenization 让 BERT 在处理英文文本的时候仅需要存储 30,522 个词，而且很少遇到 oov 的词。</p>\n<p>Token Embeddings 层会将每一个 wordpiece token 转换成 768 维的向量。这样，例子中的 6 个 token 就被转换成了一个 (6, 768) 的矩阵或者是 (1, 6, 768) 的张量（如果考虑 batch_size 的话）。</p>\n<h3><span id=\"2-segment-embeddings\"> 2 Segment Embeddings</span></h3>\n<h4><span id=\"作用\"> 作用</span></h4>\n<p>BERT 能够处理对输入句子对的分类任务。这类任务就像判断两个文本是否是语义相似的。句子对中的两个句子被简单的拼接在一起后送入到模型中。那 BERT 如何去区分一个句子对中的两个句子呢？答案就是 segment embeddings.</p>\n<h4><span id=\"实现\"> 实现</span></h4>\n<p>假设有这样一对句子 (“I like cats”, “I like dogs”)。下面的图成仙了 segment embeddings 如何帮助 BERT 区分两个句子:</p>\n<center><img src=\"https://img-blog.csdnimg.cn/20210709192014484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzIyODg3,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\" style=\"zoom:60%;\"></center>\n<p>Segment Embeddings 层只有两种向量表示。前一个向量是把 0 赋给第一个句子中的各个 token, 后一个向量是把 1 赋给第二个句子中的各个 token。如果输入仅仅只有一个句子，那么它的 segment embedding 就是全 0。</p>\n<h3><span id=\"3-position-embeddings\"> 3 Position Embeddings</span></h3>\n<h4><span id=\"作用\"> 作用</span></h4>\n<p>BERT 包含这一串 Transformers (<a href=\"https://arxiv.org/pdf/1706.03762.pdf\">Vaswani et al</a>. 2017)，而且一般认为，Transformers 无法编码输入的序列的顺序性。 <a href=\"https://medium.com/@_init_/how-self-attention-with-relative-position-representations-works-28173b8c245a\">博客</a>更加详细的解释了这一问题。总的来说，加入 position embeddings 会让 BERT 理解下面下面这种情况：</p>\n<blockquote>\n<p>I think, therefore I am</p>\n</blockquote>\n<p>第一个 “I” 和第二个 “I” 应该有着不同的向量表示。</p>\n<h4><span id=\"实现\"> 实现</span></h4>\n<p>BERT 能够处理最长 512 个 token 的输入序列。论文作者通过让 BERT 在各个位置上学习一个向量表示来讲序列顺序的信息编码进来。这意味着 Position Embeddings layer 实际上就是一个大小为 (512, 768) 的 lookup 表，表的第一行是代表第一个序列的第一个位置，第二行代表序列的第二个位置，以此类推。因此，如果有这样两个句子 “Hello world” 和 “Hi there”, “Hello” 和 “Hi” 会由完全相同的 position embeddings，因为他们都是句子的第一个词。同理，“world” 和 “there” 也会有相同的 position embedding。</p>\n<h3><span id=\"4-合成表示\"> 4 合成表示</span></h3>\n<p>我们已经介绍了长度为 n 的输入序列将获得的三种不同的向量表示，分别是：</p>\n<ul>\n<li>Token Embeddings， (1, n, 768) ，词的向量表示</li>\n<li>Segment Embeddings， (1, n, 768)，辅助 BERT 区别句子对中的两个句子的向量表示</li>\n<li>Position Embeddings ，(1, n, 768) ，让 BERT 学习到输入的顺序属性</li>\n</ul>\n<p>这些表示会被按元素相加，得到一个大小为 (1, n, 768) 的合成表示。这一表示就是 BERT 编码层的输入了。</p>\n",
            "tags": [
                "人工智能",
                "NLP-BERT"
            ]
        }
    ]
}
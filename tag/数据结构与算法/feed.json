{
    "version": "https://jsonfeed.org/version/1",
    "title": "且听风吟，御剑于心！ • All posts by \"数据结构与算法\" tag",
    "description": "",
    "home_page_url": "https://leezhao415.github.io",
    "items": [
        {
            "id": "https://leezhao415.github.io/2021/08/28/Python-%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/",
            "url": "https://leezhao415.github.io/2021/08/28/Python-%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/",
            "title": "Python 实现的十大经典排序算法",
            "date_published": "2021-08-28T07:15:08.000Z",
            "content_html": "<meta name=\"referrer\" content=\"no-referrer\">\n<hr>\n<p><strong>文章目录</strong></p>\n<!-- toc -->\n<ul>\n<li><a href=\"#python-%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95\">Python 实现的十大经典排序算法</a>\n<ul>\n<li><a href=\"#%E9%9C%80%E6%B1%82\">需求</a></li>\n<li><a href=\"#%E5%88%92%E5%88%86%E6%96%B9%E6%B3%95\">划分方法</a></li>\n<li><a href=\"#%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95\">常见排序方法</a>\n<ul>\n<li><a href=\"#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8Fselection-sort\">选择排序（Selection Sort）</a></li>\n<li><a href=\"#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8Fbubble-sort\">冒泡排序（Bubble Sort）</a></li>\n<li><a href=\"#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8Finsertion-sort\">插入排序（Insertion Sort）</a></li>\n<li><a href=\"#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8Fshell-sort\">希尔排序（Shell Sort）</a></li>\n<li><a href=\"#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8Fmerge-sort\">归并排序（Merge Sort）</a></li>\n<li><a href=\"#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8Fquick-sort\">快速排序（Quick Sort）</a></li>\n<li><a href=\"#%E5%A0%86%E6%8E%92%E5%BA%8Fheap-sort\">堆排序（Heap Sort）</a></li>\n<li><a href=\"#%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8Fcounting-sort\">计数排序（Counting Sort）</a></li>\n<li><a href=\"#%E6%A1%B6%E6%8E%92%E5%BA%8Fbucket-sort\">桶排序（Bucket Sort）</a></li>\n<li><a href=\"#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8Fradix-sort\">基数排序（Radix Sort）</a></li>\n</ul>\n</li>\n<li><a href=\"#%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93\">算法总结</a></li>\n</ul>\n</li>\n</ul>\n<!-- tocstop -->\n<hr>\n<h2><span id=\"python-实现的十大经典排序算法\"> Python 实现的十大经典排序算法</span></h2>\n<p>参考链接：<a href=\"https://blog.csdn.net/MobiusStrip/article/details/83785159?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task\">https://blog.csdn.net/MobiusStrip/article/details/83785159?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</a></p>\n<h3><span id=\"需求\"> 需求</span></h3>\n<p>对一个无序数组，根据某个关键字排序。</p>\n<h3><span id=\"划分方法\"> 划分方法</span></h3>\n<p>排序算法划分方法有：稳定性，内外排序，时空复杂度</p>\n<p>按照<strong>稳定性</strong>划分，稳定排序，如果 <code>a</code>  原本在 <code>b</code>  前面，而 <code>a=b</code> ，排序之后 <code>a</code>  仍然在 <code>b</code>  的前面；而不稳定可能出现在 <code>b</code>  之后。</p>\n<p>按照<strong>内外排序</strong>划分，内排序，所有排序操作都在内存中完成；外排序 ：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</p>\n<p>按照<strong>时空复杂度</strong>划分，时间复杂度是指运行时间，空间复杂度运行完一个程序所需内存的大小。</p>\n<h3><span id=\"常见排序方法\"> 常见排序方法</span></h3>\n<h4><span id=\"选择排序selection-sort\"> 选择排序（Selection Sort）</span></h4>\n<center><img src=\"https://pic.leetcode-cn.com/3b5a9383650b7ba01211846defeda8917d78827f02132113c57fcbd09715bf4b-849589-20171015224719590-1433219824.gif\" alt=\"849589-20171015224719590-1433219824.gif\" style=\"zoom:80%;\"></center>\n<p>这应该最符合人类思维的排序方法，工作原理，首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>\n<p>稳定性：用数组实现的选择排序是不稳定的，用链表实现的选择排序是稳定的；内排序；</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">selection_sort</span>(<span class=\"params\">nums</span>):</span></span><br><span class=\"line\">    n = <span class=\"built_in\">len</span>(nums)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(i, n):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[i] &gt; nums[j]:</span><br><span class=\"line\">                nums[i], nums[j] = nums[j], nums[i]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nums</span><br></pre></td></tr></table></figure>\n<p><strong>算法分析</strong>：</p>\n<p>时间复杂度：O (n<sup>2</sup>) ， <code>n</code>  是数组长度</p>\n<h4><span id=\"冒泡排序bubble-sort\"> 冒泡排序（Bubble Sort）</span></h4>\n<p>冒泡排序时针对<strong>相邻元素之间</strong>的比较，可以将大的数慢慢 “沉底”(数组尾部)</p>\n<center><img src=\"https://pic.leetcode-cn.com/faa1a3c1b3f1ae8a406e9c8e86bd28a9a1fb621ed6cc8eead1fe6e14ee0ec1c4-v2-d4c88b8cc620af6af67c33910899fcf7_b.gif\" alt=\"v2-d4c88b8cc620af6af67c33910899fcf7_b.gif\" style=\"zoom:80%;\"></center>\n<center><img src=\"https://pic.leetcode-cn.com/7d9af5dcad63d4097876f2614f38484f49b4e34f75c296a75001b19cf8134bb4-849589-20171015223238449-2146169197.gif\" alt=\"849589-20171015223238449-2146169197.gif\" style=\"zoom:75%;\"></center>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">bubble_sort</span>(<span class=\"params\">nums</span>):</span></span><br><span class=\"line\">    n = <span class=\"built_in\">len</span>(nums)</span><br><span class=\"line\">    <span class=\"comment\"># 进行多次循环</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, n - c):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[i - <span class=\"number\">1</span>] &gt; nums[i]:</span><br><span class=\"line\">                nums[i - <span class=\"number\">1</span>], nums[i] = nums[i], nums[i - <span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nums</span><br></pre></td></tr></table></figure>\n<p><strong>算法分析</strong>：</p>\n<p>稳定排序，内排序，时间复杂度：O (n<sup>2</sup>)</p>\n<h4><span id=\"插入排序insertion-sort\"> 插入排序（Insertion Sort）</span></h4>\n<p>插入排序是前面<strong>已排序数组</strong>找到插入的位置</p>\n<center><img src=\"https://pic.leetcode-cn.com/8ccbfd04148694bb4435bce230ff57620d7d551d060f1d077df6514966ce4f0d-Insertion-sort-example-300px.gif\" alt=\"Insertion-sort-example-300px.gif\" style=\"zoom:80%;\"></center>\n<center><img src=\"https://pic.leetcode-cn.com/bc80b45fb9b68f86b62b9fb968a377d8dbee807a5e54a9276cb684648663181f-849589-20171015225645277-1151100000.gif\" alt=\"849589-20171015225645277-1151100000.gif\" style=\"zoom:67%;\"></center>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">insertion_sort</span>(<span class=\"params\">nums</span>):</span></span><br><span class=\"line\">    n = <span class=\"built_in\">len</span>(nums)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, n):</span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> nums[i - <span class=\"number\">1</span>] &gt; nums[i]:</span><br><span class=\"line\">            nums[i - <span class=\"number\">1</span>], nums[i] = nums[i], nums[i - <span class=\"number\">1</span>]</span><br><span class=\"line\">            i -= <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> nums</span><br></pre></td></tr></table></figure>\n<p><strong>算法分析</strong>：</p>\n<p>稳定排序，<sub>内排序</sub>，时间复杂度：O (n<sup>2</sup>)</p>\n<h4><span id=\"希尔排序shell-sort\"> 希尔排序（Shell Sort）</span></h4>\n<p>插入排序进阶版，</p>\n<p><strong>算法描述：</strong></p>\n<p>我们来看下希尔排序的基本步骤，在此我们选择增量 <code>gap=length/2</code> ，缩小增量继续以 <code>gap = gap/2</code>  的方式，这种增量选择我们可以用一个序列来表示， <code>&#123;n/2,(n/2)/2…1&#125;</code> ，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。</p>\n<p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p>\n<ul>\n<li>步骤 1：选择一个增量序列 t<sub>1</sub>，t<sub>2</sub>，…，t<sub>k</sub>，其中 t<sub>i</sub>&gt;t<sub>j</sub>，t<sub>k</sub>=1；</li>\n<li>步骤 2：按增量序列个数 k，对序列进行 k 趟排序；</li>\n<li>步骤 3：每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>\n</ul>\n<center><img src=\"https://pic.leetcode-cn.com/cb7ce9df25f122c02e243d5f9b69ae4692fd3c04da25fab2c60775eb95cb6749-849589-20180331170017421-364506073.gif\" alt=\"849589-20180331170017421-364506073.gif\" style=\"zoom:80%;\"></center>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">shell_sort</span>(<span class=\"params\">nums</span>):</span></span><br><span class=\"line\">    n = <span class=\"built_in\">len</span>(nums)</span><br><span class=\"line\">    gap = n // <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> gap:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(gap, n):</span><br><span class=\"line\">            <span class=\"keyword\">while</span> i - gap &gt;= <span class=\"number\">0</span> <span class=\"keyword\">and</span> nums[i - gap] &gt; nums[i]:</span><br><span class=\"line\">                nums[i - gap], nums[i] = nums[i], nums[i - gap]</span><br><span class=\"line\">                i -= gap</span><br><span class=\"line\">        gap //= <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> nums</span><br></pre></td></tr></table></figure>\n<p><strong>算法分析</strong>：</p>\n<p>非稳定排序，内排序；</p>\n<p>希尔排序的时间复杂度和增量序列是相关的。</p>\n<p><code>&#123;1,2,4,8,...&#125;</code>  这种序列并不是很好的增量序列，使用这个增量序列的时间复杂度（最坏情形）是 O (n<sup>2</sup>)；</p>\n<p><code>Hibbard</code>  提出了另一个增量序列 1,3,7，…,2<sup>k</sup>-1，这种序列的时间复杂度 (最坏情形) 为 O (n<sup>1.5</sup>)；</p>\n<p><code>Sedgewick</code>  提出了几种增量序列，其最坏情形运行时间为 O (n<sup>1.3</sup>)，其中最好的一个序列是 <code>&#123;1,5,19,41,109,...&#125;</code> ；</p>\n<p>对于不同增量的复杂度感兴趣可以参考《数据结构与算法分析》一书或其他相关论文。</p>\n<h4><span id=\"归并排序merge-sort\"> 归并排序（Merge Sort）</span></h4>\n<p>归并排序，采用是分治法，先将数组分成子序列，让子序列有序，再将子序列间有序，合并成有序数组。</p>\n<p>算法描述：</p>\n<ol>\n<li>把长度为 <code>n</code>  的输入序列分成长度  <code>n/2</code>  的子序列；</li>\n<li>对两个子序列采用归并排序；</li>\n<li>合并所有子序列。</li>\n</ol>\n<center><img src=\"https://pic.leetcode-cn.com/96cc37ec397c0ce8edb20fc7e724f2064556f9f4b338e01930d092fd86b335f6-1252882-20190217215522179-1982419775.gif\" alt=\"1252882-20190217215522179-1982419775.gif\" style=\"zoom: 80%;\"></center>\n<center><img src=\"https://pic.leetcode-cn.com/6cd459ced71fa1f899e547c2ebbd4c51b19258e983f7bee38ef068fa81c6a863-849589-20171015230557043-37375010.gif\" alt=\"849589-20171015230557043-37375010.gif\" style=\"zoom: 67%;\"></center>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">merge_sort</span>(<span class=\"params\">nums</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(nums) &lt;= <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums</span><br><span class=\"line\">    mid = <span class=\"built_in\">len</span>(nums) // <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"comment\"># 分</span></span><br><span class=\"line\">    left = merge_sort(nums[:mid])</span><br><span class=\"line\">    right = merge_sort(nums[mid:])</span><br><span class=\"line\">    <span class=\"comment\"># 合并</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> merge(left, right)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">merge</span>(<span class=\"params\">left, right</span>):</span></span><br><span class=\"line\">    res = []</span><br><span class=\"line\">    i = <span class=\"number\">0</span></span><br><span class=\"line\">    j = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> i &lt; <span class=\"built_in\">len</span>(left) <span class=\"keyword\">and</span> j &lt; <span class=\"built_in\">len</span>(right):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> left[i] &lt;= right[j]:</span><br><span class=\"line\">            res.append(left[i])</span><br><span class=\"line\">            i += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            res.append(right[j])</span><br><span class=\"line\">            j += <span class=\"number\">1</span></span><br><span class=\"line\">    res += left[i:]</span><br><span class=\"line\">    res += right[j:]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n<p><strong>算法分析</strong>：</p>\n<p>稳定排序，外排序（占用额外内存），时间复杂度 O (nlogn)。</p>\n<h4><span id=\"快速排序quick-sort\"> 快速排序（Quick Sort）</span></h4>\n<p>快速排序是选取一个 “哨兵”( <code>pivot</code> )，将小于 <code>pivot</code>  放在左边，把大于 <code>pivot</code>  放在右边，分割成两部分，并且可以固定 <code>pivot</code>  在数组的位置，在对左右两部分继续进行排序。</p>\n<p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p>\n<ul>\n<li>步骤 1：从数列中挑出一个元素，称为 “基准”（<strong>pivot</strong> ）；</li>\n<li>步骤 2：重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>\n<li>步骤 3：递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>\n</ul>\n<center><img src=\"https://pic.leetcode-cn.com/d13bd82917a8eba049efa261bebd3beb74b9e7c1adf39ce51bf1c9dd60d49f57-Quicksort-example.gif\" alt=\"Quicksort-example.gif\" style=\"zoom:67%;\"></center>\n<center><img src=\"https://pic.leetcode-cn.com/e9ca22f1693e33a2fef64f55c10096ec93b9466459937f69eb409b0dad3f55bd-849589-20171015230936371-1413523412.gif\" alt=\"849589-20171015230936371-1413523412.gif\" style=\"zoom:75%;\"></center>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">quick_sort</span>(<span class=\"params\">nums</span>):</span></span><br><span class=\"line\">    n = <span class=\"built_in\">len</span>(nums)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">quick</span>(<span class=\"params\">left, right</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> left &gt;= right:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> nums</span><br><span class=\"line\">        pivot = left</span><br><span class=\"line\">        i = left</span><br><span class=\"line\">        j = right</span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &lt; j:</span><br><span class=\"line\">            <span class=\"keyword\">while</span> i &lt; j <span class=\"keyword\">and</span> nums[j] &gt; nums[pivot]:</span><br><span class=\"line\">                j -= <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> i &lt; j <span class=\"keyword\">and</span> nums[i] &lt;= nums[pivot]:</span><br><span class=\"line\">                i += <span class=\"number\">1</span></span><br><span class=\"line\">            nums[i], nums[j] = nums[j], nums[i]</span><br><span class=\"line\">        nums[pivot], nums[j] = nums[j], nums[pivot]</span><br><span class=\"line\">        quick(left, j - <span class=\"number\">1</span>)</span><br><span class=\"line\">        quick(j + <span class=\"number\">1</span>, right)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> quick(<span class=\"number\">0</span>, n - <span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n<p><strong>算法分析</strong>：</p>\n<p>不稳定排序，内排序，时间复杂度度 O (nlogn)。</p>\n<h4><span id=\"堆排序heap-sort\"> 堆排序（Heap Sort）</span></h4>\n<p>堆排序是利用堆这个数据结构设计的排序算法。</p>\n<p>算法描述：</p>\n<ol>\n<li>建堆，从底向上调整堆，使得父亲节点比孩子节点值大，构成大顶堆；</li>\n<li>交换堆顶和最后一个元素，重新调整堆。</li>\n</ol>\n<p>调整堆方法写了递归和迭代，都很好理解！</p>\n<center><img src=\"https://pic.leetcode-cn.com/5fbad99ff809738ba9a619cca3cb0680d5034a2e8ca8b936f44a49b67ef48c12-Heapsort-example.gif\" alt=\"Heapsort-example.gif\" style=\"zoom: 80%;\"></center>\n<center><img src=\"https://pic.leetcode-cn.com/33f8780a82b2be153c5c1e272c2aecd9eab4c3e5b2534caae02d4cfc6e0d3648-849589-20171015231308699-356134237.gif\" alt=\"849589-20171015231308699-356134237.gif\" style=\"zoom: 80%;\"></center>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">heap_sort</span>(<span class=\"params\">nums</span>):</span></span><br><span class=\"line\">    <span class=\"comment\"># 调整堆</span></span><br><span class=\"line\">    <span class=\"comment\"># 迭代写法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">adjust_heap</span>(<span class=\"params\">nums, startpos, endpos</span>):</span></span><br><span class=\"line\">        newitem = nums[startpos]</span><br><span class=\"line\">        pos = startpos</span><br><span class=\"line\">        childpos = pos * <span class=\"number\">2</span> + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> childpos &lt; endpos:</span><br><span class=\"line\">            rightpos = childpos + <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> rightpos &lt; endpos <span class=\"keyword\">and</span> nums[rightpos] &gt;= nums[childpos]:</span><br><span class=\"line\">                childpos = rightpos</span><br><span class=\"line\">            <span class=\"keyword\">if</span> newitem &lt; nums[childpos]:</span><br><span class=\"line\">                nums[pos] = nums[childpos]</span><br><span class=\"line\">                pos = childpos</span><br><span class=\"line\">                childpos = pos * <span class=\"number\">2</span> + <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">        nums[pos] = newitem</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 递归写法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">adjust_heap</span>(<span class=\"params\">nums, startpos, endpos</span>):</span></span><br><span class=\"line\">        pos = startpos</span><br><span class=\"line\">        chilidpos = pos * <span class=\"number\">2</span> + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> chilidpos &lt; endpos:</span><br><span class=\"line\">            rightpos = chilidpos + <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> rightpos &lt; endpos <span class=\"keyword\">and</span> nums[rightpos] &gt; nums[chilidpos]:</span><br><span class=\"line\">                chilidpos = rightpos</span><br><span class=\"line\">            <span class=\"keyword\">if</span> nums[chilidpos] &gt; nums[pos]:</span><br><span class=\"line\">                nums[pos], nums[chilidpos] = nums[chilidpos], nums[pos]</span><br><span class=\"line\">                adjust_heap(nums, pos, endpos)</span><br><span class=\"line\"></span><br><span class=\"line\">    n = <span class=\"built_in\">len</span>(nums)</span><br><span class=\"line\">    <span class=\"comment\"># 建堆</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">reversed</span>(<span class=\"built_in\">range</span>(n // <span class=\"number\">2</span>)):</span><br><span class=\"line\">        adjust_heap(nums, i, n)</span><br><span class=\"line\">    <span class=\"comment\"># 调整堆</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n - <span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>):</span><br><span class=\"line\">        nums[<span class=\"number\">0</span>], nums[i] = nums[i], nums[<span class=\"number\">0</span>]</span><br><span class=\"line\">        adjust_heap(nums, <span class=\"number\">0</span>, i)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nums</span><br></pre></td></tr></table></figure>\n<p><strong>算法分析</strong>：</p>\n<p>不稳定排序，内排序，时间复杂度为 O (nlogn)。</p>\n<h4><span id=\"计数排序counting-sort\"> 计数排序（Counting Sort）</span></h4>\n<p>计数排序是典型的空间换时间算法，开辟额外数据空间存储用索引号记录数组的值和数组值个数</p>\n<p>算法描述：</p>\n<ol>\n<li>找出待排序的数组的最大值和最小值</li>\n<li>统计数组值的个数</li>\n<li>反向填充目标数组</li>\n</ol>\n<center><img src=\"https://pic.leetcode-cn.com/4cc62bc0a03212520bf955bf0fb4a4bc91bf9ba571a11b827dd09a8e3d27dcdc-849589-20171015231740840-6968181.gif\" alt=\"849589-20171015231740840-6968181.gif\" style=\"zoom:67%;\"></center>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">counting_sort</span>(<span class=\"params\">nums</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> nums: <span class=\"keyword\">return</span> []</span><br><span class=\"line\">    n = <span class=\"built_in\">len</span>(nums)</span><br><span class=\"line\">    _<span class=\"built_in\">min</span> = <span class=\"built_in\">min</span>(nums)</span><br><span class=\"line\">    _<span class=\"built_in\">max</span> = <span class=\"built_in\">max</span>(nums)</span><br><span class=\"line\">    tmp_arr = [<span class=\"number\">0</span>] * (_<span class=\"built_in\">max</span> - _<span class=\"built_in\">min</span> + <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">        tmp_arr[num - _<span class=\"built_in\">min</span>] += <span class=\"number\">1</span></span><br><span class=\"line\">    j = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n):</span><br><span class=\"line\">        <span class=\"keyword\">while</span> tmp_arr[j] == <span class=\"number\">0</span>:</span><br><span class=\"line\">            j += <span class=\"number\">1</span></span><br><span class=\"line\">        nums[i] = j + _<span class=\"built_in\">min</span></span><br><span class=\"line\">        tmp_arr[j] -= <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> nums</span><br></pre></td></tr></table></figure>\n<p><strong>算法分析</strong>：</p>\n<p>稳定排序，外排序，时间复杂度 O (n + k)，但是对于数据范围很大的数组，需要大量时间和内存。</p>\n<h4><span id=\"桶排序bucket-sort\"> 桶排序（Bucket Sort）</span></h4>\n<p>桶排序是计数排序的升级版，原理是：输入数据服从均匀分布的，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的算法或是以递归方式继续使用桶排序，此文编码采用递归方式）</p>\n<p>算法描述：</p>\n<ol>\n<li>人为设置一个桶的 <code>BucketSize</code> ，作为每个桶放置多少个<strong>不同数值</strong>（意思就是 <code>BucketSize = 5</code> ，可以放 5 个不同数字比如 <code>[1, 2, 3,4,5]</code>  也可以放  <code>100000</code>  个 <code>3</code> ，只是表示该桶能存几个不同的数值）</li>\n<li>遍历待排序数据，并且把数据一个一个放到对应的桶里去</li>\n<li>对每个不是桶进行排序，可以使用其他排序方法，也递归排序</li>\n<li>不是空的桶里数据拼接起来</li>\n</ol>\n<center><img src=\"https://pic.leetcode-cn.com/000fb11d2f5cda9c6241a87926583582891552ddc7d6cd944db5e7bce75cdb76-849589-20171015232107090-1920702011.png\" alt=\"849589-20171015232107090-1920702011.png\" style=\"zoom: 80%;\"></center>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">bucket_sort</span>(<span class=\"params\">nums, bucketSize</span>):</span>    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(nums) &lt; <span class=\"number\">2</span>:        <span class=\"keyword\">return</span> nums    _<span class=\"built_in\">min</span> = <span class=\"built_in\">min</span>(nums)    _<span class=\"built_in\">max</span> = <span class=\"built_in\">max</span>(nums)    <span class=\"comment\"># 需要桶个数    bucketNum = (_max - _min) // bucketSize + 1    buckets = [[] for _ in range(bucketNum)]    for num in nums:        # 放入相应的桶中        buckets[(num - _min) // bucketSize].append(num)    res = []    for bucket in buckets:        if not bucket: continue        if bucketSize == 1:            res.extend(bucket)        else:            # 当都装在一个桶里,说明桶容量大了            if bucketNum == 1:                bucketSize -= 1            res.extend(bucket_sort(bucket, bucketSize))    return res</span></span><br></pre></td></tr></table></figure>\n<p>算法分析：</p>\n<p>稳定排序，外排序，时间复杂度 O (n + k)， <code>k</code>  为桶的个数。</p>\n<h4><span id=\"基数排序radix-sort\"> 基数排序（Radix Sort）</span></h4>\n<p>基数排序是对数字每一位进行排序，从最低位开始排序</p>\n<p>算法描述：</p>\n<ol>\n<li>找到数组最大值，得最大位数；</li>\n<li>从最低位开始取每个位组成 <code>radix</code>  数组；</li>\n<li>对 <code>radix</code>  进行计数排序（计数排序适用于小范围的特点）。</li>\n</ol>\n<center><img src=\"https://pic.leetcode-cn.com/1df246bf456e537f508a40ca8951c21f001491ea0f6c9386d65d27d4c4c091ca-849589-20171015232453668-1397662527.gif\" alt=\"849589-20171015232453668-1397662527.gif\" style=\"zoom: 67%;\"></center>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">Radix_sort</span>(<span class=\"params\">nums</span>):</span>    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> nums: <span class=\"keyword\">return</span> []    _<span class=\"built_in\">max</span> = <span class=\"built_in\">max</span>(nums)    <span class=\"comment\"># 最大位数    maxDigit = len(str(_max))    bucketList = [[] for _ in range(10)]    # 从低位开始排序    div, mod = 1, 10    for i in range(maxDigit):        for num in nums:            bucketList[num % mod // div].append(num)        div *= 10        mod *= 10        idx = 0        for j in range(10):            for item in bucketList[j]:                nums[idx] = item                idx += 1            bucketList[j] = []    return nums</span></span><br></pre></td></tr></table></figure>\n<p><strong>算法分析</strong>：</p>\n<p>稳定排序，外排序，时间复杂度 posCount * (n + n) ，其中  <code>posCount</code>  为数组中最大元素的最高位数；简化下得：$O (k *n) $；其中 k 为常数，n 为元素个数。</p>\n<h3><span id=\"算法总结\"> 算法总结</span></h3>\n<center><img src=\"https://pic.leetcode-cn.com/7c4b99fa8324e4245c2147fc9f4eb9fc23df9dc1d9dee8b2ebd9009c4100ad7e-849589-20171015233043168-1867817869.png\" alt=\"849589-20171015233043168-1867817869.png\" style=\"zoom: 67%;\"></center>\n<p><strong>图片名词解释：</strong></p>\n<ul>\n<li>n: 数据规模</li>\n<li>k: “桶” 的个数</li>\n<li>In-place: 占用常数内存，不占用额外内存</li>\n<li>Out-place: 占用额外内存</li>\n</ul>\n",
            "tags": [
                "人工智能",
                "数据结构与算法"
            ]
        },
        {
            "id": "https://leezhao415.github.io/2021/04/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/",
            "url": "https://leezhao415.github.io/2021/04/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/",
            "title": "数据结构及算法详解",
            "date_published": "2021-04-20T12:05:37.000Z",
            "content_html": "<meta name=\"referrer\" content=\"no-referrer\">\n<hr>\n<p><strong>文章目录</strong></p>\n<!-- toc -->\n<ul>\n<li><a href=\"#1-%E7%AE%97%E6%B3%95%E7%9A%84%E8%A1%A1%E9%87%8F%E6%A0%87%E5%87%86\">1 算法的衡量标准</a></li>\n<li><a href=\"#2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\">2 数据结构</a></li>\n<li><a href=\"#3-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95\">3 排序算法</a>\n<ul>\n<li><a href=\"#31-%E6%8E%92%E5%BA%8F\">3.1 排序</a></li>\n<li><a href=\"#32-%E7%AE%97%E6%B3%95%E7%A8%B3%E5%AE%9A%E6%80%A7\">3.2 算法稳定性</a></li>\n<li><a href=\"#33-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95\">3.3 排序算法</a></li>\n</ul>\n</li>\n<li><a href=\"#4-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE\">4 二分查找</a>\n<ul>\n<li><a href=\"#41-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE\">4.1 二分查找</a></li>\n<li><a href=\"#42-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\">4.2 代码实现</a>\n<ul>\n<li><a href=\"#421-%E9%80%92%E5%BD%92%E7%89%88%E6%9C%AC\">4.2.1 递归版本</a></li>\n<li><a href=\"#422-%E9%80%92%E5%BD%92%E4%BC%98%E5%8C%96%E7%89%88%E6%9C%AC\">4.2.2 递归优化版本</a></li>\n<li><a href=\"#423-%E9%9D%9E%E9%80%92%E5%BD%92%E7%89%88%E6%9C%AC\">4.2.3 非递归版本</a></li>\n<li><a href=\"#424-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-%E4%BD%8D%E7%BD%AE\">4.2.4 二分查找 - 位置</a></li>\n<li><a href=\"#425-%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE\">4.2.5 第一个位置</a></li>\n<li><a href=\"#426-%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE\">4.2.6 最后一个位置</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#5-%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91\">5 非线性数据结构 - 树</a></li>\n</ul>\n<!-- tocstop -->\n<hr>\n<h2><span id=\"1-算法的衡量标准\"> 1 算法的衡量标准</span></h2>\n<p><strong>1.1 算法</strong></p>\n<p>解决问题的办法，是一种独立的存在的解决问题的方法和思想，它不依赖于代码。代码只不过是对算法的一种表达和实现。</p>\n<p><strong>1.2 数据结构</strong></p>\n<p>存储和组织数据的方式</p>\n<p><strong>1.3 时间复杂度</strong></p>\n<p>在规模量级上对算法的衡量，表示一个算法随着问题规模不断变化的最主要趋势</p>\n<ul>\n<li>计算规则（6 条）\n<ul>\n<li><code>基本操作</code> ：只有常数项，时间复杂度为 O (1）</li>\n<li><code>顺序结构</code> ：时间复杂度按 <code>加法</code> 进行计算</li>\n<li><code>循环结构、递归结构</code> ：时间复杂度按 <code>乘法</code> 进行计算</li>\n<li><code>分支结构</code> ：时间复杂度取 <code>最大值</code></li>\n<li>判断一个算法的效率时，往往只需要关注操作数量的 <code>最高次项</code> ，忽略系数、低阶及常数项</li>\n<li>在没有特殊说明的情况下，我们所分析的算法的时间复杂度都是指 <code>最坏时间复杂度</code> （提供了一种保证，表明算法在此种程度的基本操作中一定能完成工作。）</li>\n<li><code>函数嵌套</code> ，时间复杂度按 <code>乘法</code> 计算</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>O (1） 执行次数恒定的计算</p>\n</blockquote>\n<p><strong>1.4 空间复杂度</strong></p>\n<p>一个算法在运行过程中临时消耗内存的大小的度量</p>\n<p><strong>1.5 算法的复杂度</strong></p>\n<p>算法的时间复杂度和空间复杂度的合称</p>\n<p><strong>1.6 算法五大特性</strong></p>\n<p><strong>①输入</strong>：算法具有 0 个或多个输入</p>\n<p><strong>②输出</strong>：算法至少有 1 个或多个输出</p>\n<p><strong>③有穷性</strong>：算法在有限的步骤之后会自动结束而不会无限循环，并且每一个步骤可以在可接受的时间内完成</p>\n<p><strong>④确定性</strong>：算法中的每一步都有确定的含义，不会出现二义性</p>\n<p><strong>⑤可行性</strong>：算法的每一步都是可行的，也就是说每一步都能够执行有限的次数完成</p>\n<p><strong>1.7 常见时间复杂度</strong></p>\n<table>\n<thead>\n<tr>\n<th><strong>执行次数函数举例</strong></th>\n<th><strong>阶</strong></th>\n<th><strong>非正式术语</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>12</td>\n<td>O(1)</td>\n<td>常数阶</td>\n</tr>\n<tr>\n<td>2n+3</td>\n<td>O(n)</td>\n<td>线性阶</td>\n</tr>\n<tr>\n<td>3n2+2n+1</td>\n<td>O(n2)</td>\n<td>平方阶</td>\n</tr>\n<tr>\n<td>5log2n+20</td>\n<td>O(logn)</td>\n<td>对数阶</td>\n</tr>\n<tr>\n<td>6n3+2n2+3n+4</td>\n<td>O(n3)</td>\n<td>立方阶</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>\n<p>时间复杂度曲线</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210414114352204.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzIyODg3,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li>所消耗的时间从小到大:\n<ul>\n<li><code>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n2) &lt; O(n3)</code></li>\n<li><strong>时间复杂度越低，效率越高</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2><span id=\"2-数据结构\"> 2 数据结构</span></h2>\n<p><strong>2.1 数据结构</strong></p>\n<p>数据对象中数据元素之间的关系 -</p>\n<ul>\n<li>内置数据结构：list、元组、字典等</li>\n<li>扩展数据结构：栈、队列等</li>\n</ul>\n<p><strong>2.1.1 程序 = 数据结构（问题载体） + 算法</strong></p>\n<blockquote>\n<p>高效的程序需要在数据结构基础上设计和选择算法</p>\n</blockquote>\n<p><strong>2.1.2 元素外置</strong>：地址和数据分开存储</p>\n<ul>\n<li>地址存储占用的内存空间\n<ul>\n<li>32 位操作系统： <code>4位</code></li>\n<li>64 位操作系统： <code>8位</code></li>\n</ul>\n</li>\n</ul>\n<p><strong>2.1.3 数据结构</strong></p>\n<p><strong>1 线性结构</strong></p>\n<p><strong>1.1 顺序表</strong></p>\n<ul>\n<li>一体式顺序表</li>\n<li>分离式顺序表</li>\n</ul>\n<p><strong>1.2 链表</strong></p>\n<ul>\n<li>单链表\n<ul>\n<li>元素域： 存放具体数据\n<ul>\n<li>链接域： 存放下一个节点的位置</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>1.3 栈</strong></p>\n<center><img src=\"https://img-blog.csdnimg.cn/20210414114413642.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzIyODg3,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\" style=\"zoom:50%;\"></center>\n<ul>\n<li>\n<p>1.3.1 特点：</p>\n<p>① 一种运算受限的 <code>线性表</code> ，仅允许在表的一端进行插入和删除运算，这一端被称为 <code>栈顶</code> ，相对地，把另一端称为 <code>栈底</code> .</p>\n<p>② 处理数据的时候符合 <code>先进后出（FILO）</code> 特点</p>\n</li>\n<li>\n<p>1.3.2 作用：函数里面有可能要使用到局部变量，不能总是用全局变量。而局部变量在函数使用完毕之后就销毁了，那么将局部变量存储在栈中既能不浪费空间又能及时销毁.</p>\n</li>\n<li>\n<p>1.3.3 代码实现</p>\n<ul>\n<li>\n<p>1 链表实现栈</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, data, <span class=\"built_in\">next</span>=<span class=\"literal\">None</span></span>):</span></span><br><span class=\"line\">        self.data = data</span><br><span class=\"line\">        self.<span class=\"built_in\">next</span> = <span class=\"built_in\">next</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LinkedStack</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"comment\"># 最上面的元素</span></span><br><span class=\"line\">        self.top = <span class=\"literal\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">push</span>(<span class=\"params\">self, value: <span class=\"built_in\">int</span></span>):</span></span><br><span class=\"line\">        newtop = Node(value)</span><br><span class=\"line\">        newtop.<span class=\"built_in\">next</span> = self.top</span><br><span class=\"line\">        self.top = newtop</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pop</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.top:</span><br><span class=\"line\">            value = self.top.data</span><br><span class=\"line\">            self.top = self.top.<span class=\"built_in\">next</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> value</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&quot;__main__&quot;</span>:</span><br><span class=\"line\">    stack = LinkedStack()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">9</span>):</span><br><span class=\"line\">        stack.push(i)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">9</span>):</span><br><span class=\"line\">        ele = stack.pop()</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(ele)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>1.4 队列</strong></p>\n<center><img src=\"https://img-blog.csdnimg.cn/20210414114428102.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzIyODg3,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\" style=\"zoom: 80%;\"></center>\n<ul>\n<li>\n<p>特点：</p>\n<p>① 一种操作受限的 <code>线性表</code> ，只允许在表的头部（front）(队头) 进行删除操作，而在表的尾部（rear）（队尾）进行插入操作。</p>\n<p>②  处理数据的时候符合 <code>先进先出（FIFO）</code> 特点</p>\n</li>\n<li>\n<p>作用：</p>\n<p>在任务处理类的系统中，先把用户发起的任务请求接收过来存到队列中，然后后端开启多个应用程序从队列中取任务进行处理，队列可以起到了 <code>缓冲压力</code> 的作用</p>\n</li>\n<li>\n<p>代码实现</p>\n<ul>\n<li>\n<p>列表队列优化</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 尾部入  头部出</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayQueue</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, capacity</span>):</span><span class=\"comment\"># capacity 容量</span></span><br><span class=\"line\">        <span class=\"comment\"># 申请固定长度空间</span></span><br><span class=\"line\">        self.__items = [<span class=\"number\">0</span>]*capacity</span><br><span class=\"line\">        self.__capacity = capacity</span><br><span class=\"line\">        <span class=\"comment\"># 头部指针</span></span><br><span class=\"line\">        self.__head = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"comment\"># 尾部指针(下一个元素添加到这个位置)</span></span><br><span class=\"line\">        self.__tail = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getItmes</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.__items</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">enqueue</span>(<span class=\"params\">self, item</span>):</span></span><br><span class=\"line\">        <span class=\"comment\"># 如果存满了,返回False</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.__head==<span class=\"number\">0</span> <span class=\"keyword\">and</span> self.__tail==self.__capacity:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"comment\"># 没有存满,指针到最后了  需要先把元素往前挪</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.__tail==self.__capacity:</span><br><span class=\"line\">            <span class=\"comment\"># 指针到最后了,容量没有满</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">0</span>, self.__tail - self.__head):</span><br><span class=\"line\">                self.__items[i] = self.__items[i + self.__head]</span><br><span class=\"line\">            <span class=\"comment\"># 修改尾部指针</span></span><br><span class=\"line\">            self.__tail = self.__tail - self.__head</span><br><span class=\"line\">            <span class=\"comment\"># 修改头部指针</span></span><br><span class=\"line\">            self.__head = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"comment\"># 元素添加</span></span><br><span class=\"line\">        self.__items[self.__tail] = item</span><br><span class=\"line\">        self.__tail += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dequeue</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"comment\"># 非空</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.__head != self.__tail:</span><br><span class=\"line\">            item = self.__items[self.__head]</span><br><span class=\"line\">            <span class=\"comment\"># 把头部往后移动1位</span></span><br><span class=\"line\">            self.__head += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> item</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\">arrayQ = ArrayQueue(<span class=\"number\">6</span>)</span><br><span class=\"line\">arrayQ.enqueue(<span class=\"number\">10</span>)</span><br><span class=\"line\">arrayQ.enqueue(<span class=\"number\">20</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(arrayQ.getItmes())</span><br><span class=\"line\"><span class=\"built_in\">print</span>(arrayQ.dequeue())</span><br><span class=\"line\"><span class=\"built_in\">print</span>(arrayQ.getItmes())</span><br><span class=\"line\">arrayQ.enqueue(<span class=\"number\">30</span>)</span><br><span class=\"line\">arrayQ.enqueue(<span class=\"number\">40</span>)</span><br><span class=\"line\">arrayQ.enqueue(<span class=\"number\">50</span>)</span><br><span class=\"line\">arrayQ.enqueue(<span class=\"number\">60</span>)</span><br><span class=\"line\">arrayQ.enqueue(<span class=\"number\">70</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(arrayQ.getItmes())</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>链表实现队列</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 节点</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, data, <span class=\"built_in\">next</span>=<span class=\"literal\">None</span></span>):</span></span><br><span class=\"line\">        <span class=\"comment\"># 数据</span></span><br><span class=\"line\">        self.data = data</span><br><span class=\"line\">        <span class=\"comment\"># 链接域</span></span><br><span class=\"line\">        self.<span class=\"built_in\">next</span> = <span class=\"built_in\">next</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LinkedQueue</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        self.__head = <span class=\"literal\">None</span></span><br><span class=\"line\">        self.__tail = <span class=\"literal\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">enqueue</span>(<span class=\"params\">self, value</span>):</span></span><br><span class=\"line\">        <span class=\"string\">&#x27;&#x27;&#x27;入队列&#x27;&#x27;&#x27;</span></span><br><span class=\"line\">        new_node = Node(value)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.__tail:</span><br><span class=\"line\">            <span class=\"comment\"># 非空</span></span><br><span class=\"line\">            self.__tail.<span class=\"built_in\">next</span> = new_node</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"comment\"># 空链表</span></span><br><span class=\"line\">            self.__head = new_node</span><br><span class=\"line\">        <span class=\"comment\"># 尾部指向新的节点</span></span><br><span class=\"line\">        self.__tail = new_node</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dequeue</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.__head:</span><br><span class=\"line\">            <span class=\"comment\"># 头部不为空</span></span><br><span class=\"line\">            <span class=\"comment\"># 获取头部元素</span></span><br><span class=\"line\">            value = self.__head.data</span><br><span class=\"line\">            <span class=\"comment\"># 头部指向原来的下一个节点</span></span><br><span class=\"line\">            self.__head = self.__head.<span class=\"built_in\">next</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> self.__head:</span><br><span class=\"line\">                <span class=\"comment\"># 如果头部指向None 链表为空</span></span><br><span class=\"line\">                self.__tail = <span class=\"literal\">None</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> value</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&quot;__main__&quot;</span>:</span><br><span class=\"line\">    linkQ = LinkedQueue()</span><br><span class=\"line\">    linkQ.enqueue(<span class=\"number\">10</span>)</span><br><span class=\"line\">    linkQ.enqueue(<span class=\"number\">20</span>)</span><br><span class=\"line\">    linkQ.enqueue(<span class=\"number\">30</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(linkQ.dequeue())</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(linkQ.dequeue())</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(linkQ.dequeue())</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>双端队列</p>\n</li>\n</ul>\n</li>\n</ul>\n<center><img src=\"https://img-blog.csdnimg.cn/20210414114447732.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzIyODg3,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\" style=\"zoom: 67%;\"></center>\n<p>​\t\t特点：</p>\n<ul>\n<li>一种具有队列和栈的性质的数据结构</li>\n<li>双端队列中的元素可以从两端弹出，其限定插入和删除操作在表的两端进行</li>\n<li>双端队列可以在队列任意一端入队和出队</li>\n</ul>\n<p><strong>2 非线性结构</strong></p>\n<ul>\n<li>树</li>\n</ul>\n<h2><span id=\"3-排序算法\"> 3 排序算法</span></h2>\n<h4><span id=\"31-排序\"> 3.1 排序</span></h4>\n<p>使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。</p>\n<h4><span id=\"32-算法稳定性\"> 3.2 算法稳定性</span></h4>\n<p>假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，则称这种排序算法是稳定的，否则称为不稳定的。</p>\n<h4><span id=\"33-排序算法\"> 3.3 排序算法</span></h4>\n<ul>\n<li>\n<p><code>不稳定算法</code> : <u>选择排序</u>、<u>快速排序</u>、希尔排序、堆排序</p>\n</li>\n<li>\n<p><code>稳定算法</code> : <u>冒泡排序</u>、<u>插入排序</u>、归并排序和基数排序</p>\n</li>\n</ul>\n<p>3.3.1 代码实现</p>\n<p><strong>1 冒泡排序</strong></p>\n<ul>\n<li>\n<p>特点：</p>\n<p>重复地走访过要排序的元素列，依次比较两个相邻的元素，如果顺序（如从大到小、首字母从从 Z 到 A）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成</p>\n<blockquote>\n<p><strong>名字由来</strong>：因为越小的元素会经由交换慢慢 “浮” 到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名 “冒泡排序”</p>\n</blockquote>\n</li>\n<li>\n<p>复杂度分析：</p>\n<ul>\n<li>\n<p>最差时间复杂度 :  <code>O(n^2)</code></p>\n</li>\n<li>\n<p>最优时间复杂度 :  <code>O(n)   </code>        # 遍历一遍发现没有任何元素发生了位置交换，终止排序</p>\n</li>\n<li>\n<p>算法稳定性：稳定算法</p>\n</li>\n<li>\n<p>原地排序：是</p>\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># n-1+n-2+...+1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">bubble_sort</span>(<span class=\"params\">alist</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;&#x27;&#x27;冒泡排序&#x27;&#x27;&#x27;</span></span><br><span class=\"line\">    length = <span class=\"built_in\">len</span>(alist)</span><br><span class=\"line\">    count= <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(length-<span class=\"number\">1</span>):</span><br><span class=\"line\">        flag = <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(length-<span class=\"number\">1</span>-i):</span><br><span class=\"line\">            count+=<span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> alist[j] &gt; alist[j+<span class=\"number\">1</span>]:</span><br><span class=\"line\">                alist[j], alist[j+<span class=\"number\">1</span>] = alist[j+<span class=\"number\">1</span>], alist[j]</span><br><span class=\"line\">                flag = <span class=\"literal\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> flag:</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(count)</span><br><span class=\"line\"><span class=\"comment\"># 4+3+2+1</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    <span class=\"comment\"># l = [5,3,4,7,2]</span></span><br><span class=\"line\">    l = [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>]</span><br><span class=\"line\">    bubble_sort(l)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(l)</span><br></pre></td></tr></table></figure>\n<p><strong>2 选择排序</strong></p>\n<ul>\n<li>\n<p>特点：</p>\n<p>第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零.</p>\n</li>\n<li>\n<p>复杂度分析：</p>\n<ul>\n<li>\n<p>最差时间复杂度 :  <code>O(n^2)</code></p>\n</li>\n<li>\n<p>最优时间复杂度 :  <code>O(n^2) </code></p>\n</li>\n<li>\n<p>算法稳定性：不稳定算法</p>\n</li>\n<li>\n<p>原地排序：是</p>\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">select_sort</span>(<span class=\"params\">alist</span>):</span></span><br><span class=\"line\">    <span class=\"comment\"># 5</span></span><br><span class=\"line\">    length = <span class=\"built_in\">len</span>(alist)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(length-<span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"comment\"># 设置目标</span></span><br><span class=\"line\">        <span class=\"comment\"># targetIndex = i</span></span><br><span class=\"line\">        <span class=\"comment\"># 设置最小值索引</span></span><br><span class=\"line\">        minIndex = i</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(i+<span class=\"number\">1</span>,length):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> alist[j] &lt; alist[minIndex]:</span><br><span class=\"line\">                minIndex = j</span><br><span class=\"line\">        <span class=\"comment\"># 如果目标和最小值索引不同 交换</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> minIndex!=i:</span><br><span class=\"line\">            alist[i], alist[minIndex] = alist[minIndex], alist[i]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    alist = [<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">10</span>,<span class=\"number\">0</span>,<span class=\"number\">1000</span>,<span class=\"number\">88</span>]</span><br><span class=\"line\">    select_sort(alist)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(alist)</span><br></pre></td></tr></table></figure>\n<p><strong>3 插入排序</strong></p>\n<ul>\n<li>\n<p>特点：</p>\n<p>将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序。（每步将一个待排序的记录，按排序要求插入到前面已经排序的数据中适当位置上，直到全部插入完为止）</p>\n</li>\n<li>\n<p>复杂度分析：</p>\n<ul>\n<li>最差时间复杂度: <code>O(n^2)</code></li>\n<li>最优时间复杂度: <code>O(n)</code></li>\n<li>算法稳定性：稳定的排序方法</li>\n<li>原地排序：是</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">insert_sort</span>(<span class=\"params\">alist</span>):</span></span><br><span class=\"line\">    length = <span class=\"built_in\">len</span>(alist)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>,length):</span><br><span class=\"line\">        <span class=\"comment\"># i每一次需要排序的结束索引</span></span><br><span class=\"line\">        <span class=\"comment\"># 0 - 1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(i,<span class=\"number\">0</span>,-<span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> alist[j] &lt; alist[j-<span class=\"number\">1</span>]:</span><br><span class=\"line\">                alist[j], alist[j-<span class=\"number\">1</span>] = alist[j-<span class=\"number\">1</span>], alist[j]</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    alist = [<span class=\"number\">1</span>, <span class=\"number\">100</span>, <span class=\"number\">99</span>, <span class=\"number\">20</span>, <span class=\"number\">5</span>, <span class=\"number\">1000</span>]</span><br><span class=\"line\">    insert_sort(alist)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(alist)</span><br></pre></td></tr></table></figure>\n<p><strong>4 快速排序</strong></p>\n<ul>\n<li>\n<p>特点：</p>\n<p>通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>\n</li>\n<li>\n<p>排序流程：</p>\n<p>(1) 首先设定一个分界值，通过该分界值将数组分成左右两部分</p>\n<p>(2) 将大于或等于分界值的数据集中到数组右边，小于分界值的数据集中到数组的左边，此时，左边部分中各元素都小于或等于分界值，而右边部分中各元素都大于或等于分界值</p>\n<p>(3) 然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也做类似处理</p>\n<p>(4) 重复上述过程，可以看出，这是一个递归定义。通过递归将左侧部分排好序后，再递归排好右侧部分的顺序，当左、右两个部分各数据排序完成后，整个数组的排序也就完成了</p>\n</li>\n<li>\n<p>复杂度分析：</p>\n<ul>\n<li>\n<p>最优时间复杂度:  <code>O(nlogn)</code></p>\n</li>\n<li>\n<p>最差时间复杂度:  <code>O(n^2)</code></p>\n</li>\n<li>\n<p>算法稳定性：不稳定</p>\n</li>\n<li>\n<p>原地排序：是</p>\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">quick_sort</span>(<span class=\"params\">alist,start,end</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> start&gt;=end:</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"comment\"># 界限值</span></span><br><span class=\"line\">    mid = alist[start]</span><br><span class=\"line\">    <span class=\"comment\"># 左右游标</span></span><br><span class=\"line\">    left = start</span><br><span class=\"line\">    right = end</span><br><span class=\"line\">    <span class=\"keyword\">while</span> left &lt; right:</span><br><span class=\"line\">        <span class=\"comment\"># 从右边开始找寻小于mid的值 归类到左边</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> alist[right] &gt;= mid <span class=\"keyword\">and</span> left &lt; right:</span><br><span class=\"line\">            right -= <span class=\"number\">1</span></span><br><span class=\"line\">        alist[left] = alist[right]</span><br><span class=\"line\">        <span class=\"comment\"># 从左边开始找寻大于mid的值 归类到右边</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> alist[left] &lt; mid <span class=\"keyword\">and</span> left &lt; right:</span><br><span class=\"line\">            left += <span class=\"number\">1</span></span><br><span class=\"line\">        alist[right] = alist[left]</span><br><span class=\"line\">    <span class=\"comment\"># left=right</span></span><br><span class=\"line\">    alist[left] = mid</span><br><span class=\"line\">    <span class=\"comment\"># 排序左边</span></span><br><span class=\"line\">    quick_sort(alist,start,left-<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"comment\"># 排序右边</span></span><br><span class=\"line\">    quick_sort(alist,left+<span class=\"number\">1</span>,end)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    alist = [<span class=\"number\">5</span>,<span class=\"number\">9</span>,<span class=\"number\">8</span>,<span class=\"number\">7</span>,<span class=\"number\">6</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\">    quick_sort(alist,<span class=\"number\">0</span>,<span class=\"built_in\">len</span>(alist)-<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(alist)</span><br></pre></td></tr></table></figure>\n<h2><span id=\"4-二分查找\"> 4 二分查找</span></h2>\n<h4><span id=\"41-二分查找\"> 4.1 二分查找</span></h4>\n<ul>\n<li>\n<p>特点</p>\n<pre><code>\t二分查找又称`折半查找`，它是一种效率较高的查找方法，①必须采用顺序存储结构 ②必须按关键字大小有序排列。\n</code></pre>\n</li>\n<li>\n<p>基本思想</p>\n<pre><code>\t将数组分为三部分，依次是中值前，中值，中值后，将要查找的值与中值进行比较，若小于中值则在中值前面找，若大于中值则在中值后面找，等于中值时直接返回。\n</code></pre>\n</li>\n<li>\n<p>复杂度分析</p>\n<ul>\n<li>\n<p>最差时间复杂度:  <code>O(logn)</code></p>\n</li>\n<li>\n<p>最优时间复杂度:  <code>O(1)</code></p>\n</li>\n</ul>\n</li>\n</ul>\n<h4><span id=\"42-代码实现\"> 4.2 代码实现</span></h4>\n<h5><span id=\"421-递归版本\"> 4.2.1 递归版本</span></h5>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">binary_search</span>(<span class=\"params\">alist, item</span>):</span></span><br><span class=\"line\">    <span class=\"comment\"># 数列的长度</span></span><br><span class=\"line\">    n = <span class=\"built_in\">len</span>(alist)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> n==<span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"comment\"># 递归的结束条件</span></span><br><span class=\"line\">    <span class=\"comment\"># 中间值索引</span></span><br><span class=\"line\">    mid = n // <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> item == alist[mid]:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">    <span class=\"keyword\">elif</span> item &lt; alist[mid]:</span><br><span class=\"line\">        <span class=\"comment\"># 左边</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> binary_search(alist[:mid],item)</span><br><span class=\"line\">    <span class=\"keyword\">elif</span> item &gt; alist[mid]:</span><br><span class=\"line\">        <span class=\"comment\"># 右边</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> binary_search(alist[mid+<span class=\"number\">1</span>:],item)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    alist = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>]</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(binary_search(alist, <span class=\"number\">5</span>))</span><br></pre></td></tr></table></figure>\n<h5><span id=\"422-递归优化版本\"> 4.2.2 递归优化版本</span></h5>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">binary_search_achieve</span>(<span class=\"params\">alist, item, start, end</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;二分查找&quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> start &gt; end:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"comment\"># 中间值索引</span></span><br><span class=\"line\">    mid = (start + end) // <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> item == alist[mid]:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mid</span><br><span class=\"line\">    <span class=\"keyword\">elif</span> item &lt; alist[mid]:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> binary_search_achieve(alist, item, start, mid - <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">elif</span> item &gt; alist[mid]:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> binary_search_achieve(alist, item, mid + <span class=\"number\">1</span>, end)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">binary_search</span>(<span class=\"params\">alist, item</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> binary_search_achieve(alist, item, <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(alist) - <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 40亿 32  2^32</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    alist = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>]</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(binary_search(alist, <span class=\"number\">8</span>))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(binary_search(alist, <span class=\"number\">100</span>))</span><br></pre></td></tr></table></figure>\n<h5><span id=\"423-非递归版本\"> 4.2.3 非递归版本</span></h5>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">binary_search</span>(<span class=\"params\">alist, item</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;二分查找&quot;&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 设置起始位置 获取中间值</span></span><br><span class=\"line\">    start = <span class=\"number\">0</span></span><br><span class=\"line\">    end = <span class=\"built_in\">len</span>(alist) - <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"comment\"># 必须要=  需要比较最后的一个元素是否是需要的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> start &lt;= end:</span><br><span class=\"line\">        <span class=\"comment\"># 获取中间值</span></span><br><span class=\"line\">        <span class=\"comment\"># mid = (start+end)//2</span></span><br><span class=\"line\">        <span class=\"comment\"># end//2+start//2</span></span><br><span class=\"line\">        mid = start+(end-start)//<span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"comment\"># start+(end-start)//2</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> item == alist[mid]:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mid</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> item &lt; alist[mid]:</span><br><span class=\"line\">            end = mid - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> item &gt; alist[mid]:</span><br><span class=\"line\">            start = mid + <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 没有找到想要找的数字</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 最好 O(1) 最坏 O(logn)</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    alist = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>]</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(binary_search(alist, <span class=\"number\">1</span>))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(binary_search(alist, <span class=\"number\">5</span>))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(binary_search(alist, <span class=\"number\">100</span>))</span><br></pre></td></tr></table></figure>\n<h5><span id=\"424-二分查找-位置\"> 4.2.4 二分查找 - 位置</span></h5>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">binary_search_first</span>(<span class=\"params\">alist, item</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;二分查找 如果找到返回索引  没有找到返回-1&quot;&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 设置起始位置 获取中间值</span></span><br><span class=\"line\">    start = <span class=\"number\">0</span></span><br><span class=\"line\">    end = <span class=\"built_in\">len</span>(alist) - <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"comment\"># 必须要=  需要比较最后的一个元素是否是需要的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> start &lt;= end:</span><br><span class=\"line\">        <span class=\"comment\"># 获取中间值</span></span><br><span class=\"line\">        mid = (start + end)//<span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> item == alist[mid]:</span><br><span class=\"line\">            <span class=\"comment\"># 索引为0 不需要继续查找</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> mid==<span class=\"number\">0</span> <span class=\"keyword\">or</span> alist[mid-<span class=\"number\">1</span>]!=item:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> mid</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                end = mid - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> item &lt; alist[mid]:</span><br><span class=\"line\">            end = mid - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> item &gt; alist[mid]:</span><br><span class=\"line\">            start = mid + <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 没有找到想要找的数字</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"comment\"># 最好 O(1) 最坏 O(logn)</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    alist = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">5</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>]</span><br><span class=\"line\">    <span class=\"comment\"># print(binary_search(alist, 1))</span></span><br><span class=\"line\">    <span class=\"comment\"># print(binary_search(alist, 1))</span></span><br><span class=\"line\">    <span class=\"comment\"># 获取最后一个5</span></span><br><span class=\"line\">    <span class=\"comment\"># print(binary_search_last(alist, 5))</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(binary_search_first(alist, <span class=\"number\">5</span>))</span><br></pre></td></tr></table></figure>\n<h5><span id=\"425-第一个位置\"> 4.2.5 第一个位置</span></h5>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">binary_search</span>(<span class=\"params\">alist, item</span>):</span></span><br><span class=\"line\">      <span class=\"string\">&quot;&quot;&quot;二分查找 如果找到返回索引  没有找到返回-1&quot;&quot;&quot;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">      <span class=\"comment\"># 设置起始位置 获取中间值</span></span><br><span class=\"line\">      start = <span class=\"number\">0</span></span><br><span class=\"line\">      end = <span class=\"built_in\">len</span>(alist) - <span class=\"number\">1</span></span><br><span class=\"line\">      <span class=\"comment\"># 必须要=  需要比较最后的一个元素是否是需要的数据</span></span><br><span class=\"line\">      <span class=\"keyword\">while</span> start &lt;= end:</span><br><span class=\"line\">          <span class=\"comment\"># 获取中间值</span></span><br><span class=\"line\">          mid = (start + end)//<span class=\"number\">2</span></span><br><span class=\"line\">  </span><br><span class=\"line\">          <span class=\"keyword\">if</span> item == alist[mid]:</span><br><span class=\"line\">              <span class=\"comment\"># 判断是否是第一个3</span></span><br><span class=\"line\">              <span class=\"keyword\">if</span> mid==<span class=\"number\">0</span> <span class=\"keyword\">or</span> alist[mid-<span class=\"number\">1</span>]!=item:</span><br><span class=\"line\">                  <span class=\"keyword\">return</span> mid</span><br><span class=\"line\">              <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                  end = mid - <span class=\"number\">1</span></span><br><span class=\"line\">          <span class=\"keyword\">elif</span> item &lt; alist[mid]:</span><br><span class=\"line\">              end = mid - <span class=\"number\">1</span></span><br><span class=\"line\">          <span class=\"keyword\">elif</span> item &gt; alist[mid]:</span><br><span class=\"line\">              start = mid + <span class=\"number\">1</span></span><br><span class=\"line\">  </span><br><span class=\"line\">      <span class=\"comment\"># 没有找到想要找的数字</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> -<span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"comment\"># 最好 O(1) 最坏 O(logn)</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">      alist = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">3</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>]</span><br><span class=\"line\">      <span class=\"built_in\">print</span>(binary_search(alist, <span class=\"number\">3</span>))</span><br></pre></td></tr></table></figure>\n<h5><span id=\"426-最后一个位置\"> 4.2.6 最后一个位置</span></h5>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">binary_search</span>(<span class=\"params\">alist, item</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;二分查找 如果找到返回索引  没有找到返回-1&quot;&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 设置起始位置 获取中间值</span></span><br><span class=\"line\">    start = <span class=\"number\">0</span></span><br><span class=\"line\">    maxIndex = <span class=\"built_in\">len</span>(alist) - <span class=\"number\">1</span></span><br><span class=\"line\">    end = maxIndex</span><br><span class=\"line\">    <span class=\"comment\"># 必须要=  需要比较最后的一个元素是否是需要的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> start &lt;= end:</span><br><span class=\"line\">        <span class=\"comment\"># 获取中间值</span></span><br><span class=\"line\">        mid = (start + end)//<span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> item == alist[mid]:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> mid == maxIndex <span class=\"keyword\">or</span> alist[mid+<span class=\"number\">1</span>]!=item:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> mid</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                start = mid + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> item &lt; alist[mid]:</span><br><span class=\"line\">            end = mid - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> item &gt; alist[mid]:</span><br><span class=\"line\">            start = mid + <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 没有找到想要找的数字</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"comment\"># 最好 O(1) 最坏 O(logn)</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    alist = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">3</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>]</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(binary_search(alist, <span class=\"number\">3</span>))</span><br></pre></td></tr></table></figure>\n<h2><span id=\"5-非线性数据结构-树\"> 5 非线性数据结构 - 树</span></h2>\n<p><strong>5.1 特点</strong></p>\n<p>一种 <code>非线性结构</code> ，用来模拟具有树状结构性质的数据集合。它是由 n（n&gt;=1）个有限节点组成一个具有层次关系的集合。</p>\n<p>①每个节点有零个或多个子节点</p>\n<p>②没有父节点的节点称为根节点</p>\n<p>③每一个非根节点有且只有一个父节点</p>\n<p>④除了根节点外，每个子节点可以分为多个不相交的子树</p>\n<blockquote>\n<p><strong>名字由来</strong>：因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的.</p>\n</blockquote>\n<ul>\n<li>\n<p>拓展：线性结构和非线性结构</p>\n<ul>\n<li>\n<p>线性结构：数据元素之间存在着 “一对一” 的线性关系的数据结构</p>\n<ul>\n<li>\n<p>特点</p>\n<p>①集合中必存在唯一的一个 &quot; 第一个元素”</p>\n<p>②集合中必存在唯一的一个 &quot;最后的元素&quot;</p>\n<p>③除最后元素之外，其它数据元素均有唯一的 &quot;后继&quot;</p>\n<p>④除第一元素之外，其它数据元素均有唯一的 &quot; 前驱”</p>\n</li>\n</ul>\n</li>\n<li>\n<p>非线性结构：一个结点元素可能对应多个直接前驱和多个后继的数据结构</p>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>5.2 树的术语</strong></p>\n<ul>\n<li><code>节点的度</code> ：一个节点含有的子树的个数称为该节点的度</li>\n<li><code>树的度</code> ：一棵树中，最大的节点的度称为树的度</li>\n<li><code>叶节点或终端节点</code> ：度为零的节点</li>\n<li><code>父亲节点或父节点</code> ：若一个节点含有子节点，则这个节点称为其子节点的父节点</li>\n<li><code>孩子节点或子节点</code> ：一个节点含有的子树的根节点称为该节点的子节点</li>\n<li><code>兄弟节点</code> ：具有相同父节点的节点互称为兄弟节点</li>\n<li><code>节点的层次</code> ：从根开始定义起，根为第 1 层，根的子节点为第 2 层，以此类推</li>\n<li><code>树的高度或深度</code> ：树中节点的最大层次</li>\n<li><code>堂兄弟节点</code> ：父节点在同一层的节点互为堂兄弟</li>\n<li><code>节点的祖先</code> ：从根到该节点所经分支上的所有节点</li>\n<li><code>子孙</code> ：以某节点为根的子树中任一节点都称为该节点的子孙</li>\n<li><code>森林</code> ：由 m（m&gt;=0）棵互不相交的树的集合称为森林</li>\n</ul>\n<p><strong>5.3 树的分类</strong></p>\n<p><strong>5.3.1  <code>无序树</code> </strong></p>\n<p>树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为自由树</p>\n<p><strong>5.3.2  <code>有序树</code> </strong></p>\n<p>树中任意节点的子节点之间有顺序关系，这种树称为有序树<br>\n -  <code>霍夫曼树</code> （用于信息编码）：带权路径最短的二叉树称为哈夫曼树或最优二叉树<br>\n -  <code>B树</code> ：一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多于两个的子树</p>\n<p><strong>1 二叉树</strong></p>\n<ul>\n<li>\n<p>特点：每个节点最多含有两个子树的树，通常子树被称作 “左子树”（left subtree）和 “右子树”（right subtree）</p>\n</li>\n<li>\n<p>分类</p>\n<ul>\n<li>\n<p><code>完全二叉树</code> ：对于一颗二叉树，假设其深度为 d (d&gt;1)。除了第 d 层外，其它各层的节点数目均已达最大值，且第 d 层所有节点从左向右连续地紧密排列的二叉树。</p>\n</li>\n<li>\n<p><code>满二叉树</code> ：所有叶节点都在最底层的完全二叉树</p>\n</li>\n<li>\n<p><code>平衡二叉树</code> （AVL 树）：当且仅当任何节点的两棵子树的高度差不大于 1 的二叉树</p>\n</li>\n<li>\n<p><code>排序二叉树</code> （二叉查找树（英语：Binary Search Tree），也称二叉搜索树、有序二叉树）</p>\n</li>\n</ul>\n</li>\n<li>\n<p>基本要求</p>\n<p>（1）若左子树不空，则左子树上所有节点的值均小于它的根节点的值</p>\n<p>（2）若右子树不空，则右子树上所有节点的值均大于它的根节点的值</p>\n<p>（3）左、右子树也分别为二叉排序树</p>\n<blockquote>\n<p>排序二叉树包含空树</p>\n</blockquote>\n</li>\n<li>\n<p>存储方式</p>\n<ul>\n<li><code>顺序存储</code> ：将数据结构存储在固定的数组中，虽然在遍历速度上有一定的优势，但因所占空间比较大，是非主流二叉树存储方式。</li>\n<li><code>链式存储</code> ：由于对节点的个数无法掌握，常见树的存储表示都转换成二叉树进行处理，子节点个数最多为 2</li>\n</ul>\n</li>\n<li>\n<p>应用场景</p>\n<p>①xml，html 等，那么编写这些东西的解析器的时候，不可避免用到树<br>\n②路由协议就是使用了树的算法<br>\n③mysql 数据库索引<br>\n④文件系统的目录结构<br>\n⑤所以很多经典的 AI 算法其实都是树搜索，此外机器学习中的 decision tree 也是树结构</p>\n</li>\n<li>\n<p>性质：</p>\n<p>性质 1: 在二叉树的第 i 层上至多有 <code>2^(i-1)</code>  个结点（i&gt;0）<br>\n性质 2: 深度为 k 的二叉树至多有 <code>2^k-1</code>  个结点（k&gt;0）<br>\n性质 3: 对于任意一棵二叉树，如果其叶结点数为 N0，而度数为 2 的结点总数为 N2，则 <code>N0=N2+1</code> <br>\n 性质 4: 最多有 n 个结点的完全二叉树的深度必为  <code>log2(n+1)</code> <br>\n 性质 5: 对完全二叉树，若从上至下、从左至右编号，则编号为 i 的结点，其左孩子编号必为 <code>2i</code> ，其右孩子编号必为 <code>2i＋1</code>  , 其父节点的编号必为 <code>i//2</code> （i＝1 时为根，除外）</p>\n</li>\n<li>\n<p>代码实现</p>\n<ul>\n<li>\n<p>完全二叉树</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> queue</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>(<span class=\"params\"><span class=\"built_in\">object</span></span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;节点类&quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, item</span>):</span></span><br><span class=\"line\">        <span class=\"comment\"># 数据类型  10</span></span><br><span class=\"line\">        self.item = item</span><br><span class=\"line\">        <span class=\"comment\"># Node</span></span><br><span class=\"line\">        self.lchild = <span class=\"literal\">None</span></span><br><span class=\"line\">        <span class=\"comment\"># Node</span></span><br><span class=\"line\">        self.rchild = <span class=\"literal\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BinaryTree</span>(<span class=\"params\"><span class=\"built_in\">object</span></span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;二叉树&quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, node=<span class=\"literal\">None</span></span>):</span></span><br><span class=\"line\">        <span class=\"comment\"># Node类型  根节点</span></span><br><span class=\"line\">        self.root = node</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add</span>(<span class=\"params\">self, item</span>):</span></span><br><span class=\"line\">        add_node = Node(item)</span><br><span class=\"line\">        <span class=\"comment\"># 空二叉树</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.root == <span class=\"literal\">None</span>:</span><br><span class=\"line\">            self.root = add_node</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">        my_queue =  queue.Queue()</span><br><span class=\"line\">        <span class=\"comment\"># 把root放入到队列中</span></span><br><span class=\"line\">        my_queue.put(self.root)</span><br><span class=\"line\">        <span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">            <span class=\"comment\"># 获取元素</span></span><br><span class=\"line\">            node = my_queue.get()</span><br><span class=\"line\">            <span class=\"comment\"># 左右节点是否为空</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> node.lchild == <span class=\"literal\">None</span>:</span><br><span class=\"line\">                node.lchild = add_node</span><br><span class=\"line\">                <span class=\"keyword\">return</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> node.rchild == <span class=\"literal\">None</span>:</span><br><span class=\"line\">                node.rchild = add_node</span><br><span class=\"line\">                <span class=\"keyword\">return</span></span><br><span class=\"line\">            <span class=\"comment\"># 放入左右节点</span></span><br><span class=\"line\">            my_queue.put(node.lchild)</span><br><span class=\"line\">            my_queue.put(node.rchild)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">breadh_travel</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;广度优先遍历&quot;&quot;&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> self.root:</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"comment\"># 定义队列</span></span><br><span class=\"line\">        my_queue = queue.Queue()</span><br><span class=\"line\">        <span class=\"comment\"># 放入根节点</span></span><br><span class=\"line\">        my_queue.put(self.root)</span><br><span class=\"line\">        <span class=\"keyword\">while</span> <span class=\"keyword\">not</span> my_queue.empty():</span><br><span class=\"line\">            node = my_queue.get()</span><br><span class=\"line\">            <span class=\"comment\"># 当前节点数据打印</span></span><br><span class=\"line\">            <span class=\"built_in\">print</span>(node.item,end=<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">            <span class=\"comment\"># 左右节点添加到队列中</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> node.lchild:</span><br><span class=\"line\">                my_queue.put(node.lchild)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> node.rchild:</span><br><span class=\"line\">                my_queue.put(node.rchild)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">preorder_travel_out</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        self.__preorder_travel(self.root)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__preorder_travel</span>(<span class=\"params\">self, root</span>):</span></span><br><span class=\"line\">        <span class=\"string\">&#x27;&#x27;&#x27;先序遍历: 给根节点 可以把这个节点按照根左右的方式遍历出来&#x27;&#x27;&#x27;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> root:</span><br><span class=\"line\">            <span class=\"comment\"># 根</span></span><br><span class=\"line\">            <span class=\"built_in\">print</span>(root.item,end=<span class=\"string\">&#x27;&#x27;</span>)<span class=\"comment\"># 0</span></span><br><span class=\"line\">            <span class=\"comment\"># 左子树</span></span><br><span class=\"line\">            self.__preorder_travel(root.lchild)</span><br><span class=\"line\">            <span class=\"comment\"># 右子树</span></span><br><span class=\"line\">            self.__preorder_travel(root.rchild)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 给一个节点 就可以对这个节点以及这个节点一下的节点进行中序遍历</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">inorder_travel</span>(<span class=\"params\">self, root</span>):</span></span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;中序遍历 左 根 右&quot;&quot;&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> root <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            self.inorder_travel(root.lchild)</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(root.item, end=<span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">            self.inorder_travel(root.rchild)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 给一个节点 就可以对这个节点以及这个节点一下的节点进行后序遍历</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">postorder_travel</span>(<span class=\"params\">self, root</span>):</span></span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;后序遍历 根 左 右&quot;&quot;&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> root <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            self.postorder_travel(root.lchild)</span><br><span class=\"line\">            self.postorder_travel(root.rchild)</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(root.item, end=<span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    tree = BinaryTree()</span><br><span class=\"line\">    tree.add(<span class=\"string\">&quot;0&quot;</span>)</span><br><span class=\"line\">    tree.add(<span class=\"string\">&quot;1&quot;</span>)</span><br><span class=\"line\">    tree.add(<span class=\"string\">&quot;2&quot;</span>)</span><br><span class=\"line\">    tree.add(<span class=\"string\">&quot;3&quot;</span>)</span><br><span class=\"line\">    tree.add(<span class=\"string\">&quot;4&quot;</span>)</span><br><span class=\"line\">    tree.add(<span class=\"string\">&quot;5&quot;</span>)</span><br><span class=\"line\">    tree.add(<span class=\"string\">&quot;6&quot;</span>)</span><br><span class=\"line\">    tree.add(<span class=\"string\">&quot;7&quot;</span>)</span><br><span class=\"line\">    tree.add(<span class=\"string\">&quot;8&quot;</span>)</span><br><span class=\"line\">    tree.add(<span class=\"string\">&quot;9&quot;</span>)</span><br><span class=\"line\">    tree.postorder_travel(tree.root)</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>完全二叉树添加节点</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> queue</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>(<span class=\"params\"><span class=\"built_in\">object</span></span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;节点类&quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span>  <span class=\"title\">__init__</span>(<span class=\"params\">self, item</span>):</span></span><br><span class=\"line\">        self.item = item</span><br><span class=\"line\">        self.lchild = <span class=\"literal\">None</span></span><br><span class=\"line\">        self.rchild = <span class=\"literal\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BinaryTree</span>(<span class=\"params\"><span class=\"built_in\">object</span></span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;完全二叉树&quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, node=<span class=\"literal\">None</span></span>):</span></span><br><span class=\"line\">        self.root = node</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add</span>(<span class=\"params\">self, item</span>):</span></span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;添加节点&quot;&quot;&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.root == <span class=\"literal\">None</span>:</span><br><span class=\"line\">            self.root = Node(item)</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 队列</span></span><br><span class=\"line\">        que = queue.Queue()</span><br><span class=\"line\">        <span class=\"comment\"># 从尾部添加数据</span></span><br><span class=\"line\">        que.put(self.root)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">            <span class=\"comment\"># 从头部取出数据</span></span><br><span class=\"line\">            node = que.get()</span><br><span class=\"line\">            <span class=\"comment\"># 判断左节点是否为空</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> node.lchild == <span class=\"literal\">None</span>:</span><br><span class=\"line\">                node.lchild = Node(item)</span><br><span class=\"line\">                <span class=\"keyword\">return</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                que.put(node.lchild)</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> node.rchild == <span class=\"literal\">None</span>:</span><br><span class=\"line\">                node.rchild = Node(item)</span><br><span class=\"line\">                <span class=\"keyword\">return</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                que.put(node.rchild)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">breadh_travel</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;广度优先遍历&quot;&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.root == <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 队列</span></span><br><span class=\"line\">        que = queue.Queue()</span><br><span class=\"line\">        <span class=\"comment\"># 添加数据</span></span><br><span class=\"line\">        que.put(self.root)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> <span class=\"keyword\">not</span> que.empty():</span><br><span class=\"line\">        <span class=\"comment\"># while queue:</span></span><br><span class=\"line\">            <span class=\"comment\"># 取出数据</span></span><br><span class=\"line\">            node = que.get()</span><br><span class=\"line\">            <span class=\"comment\"># 当前节点数据</span></span><br><span class=\"line\">            <span class=\"built_in\">print</span>(node.item, end=<span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\"># 判断左右子节点是否为空</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> node.lchild <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">                que.put(node.lchild)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> node.rchild <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">                que.put(node.rchild)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    tree = BinaryTree()</span><br><span class=\"line\">    tree.add(<span class=\"string\">&quot;A&quot;</span>)</span><br><span class=\"line\">    tree.add(<span class=\"string\">&quot;B&quot;</span>)</span><br><span class=\"line\">    tree.add(<span class=\"string\">&quot;C&quot;</span>)</span><br><span class=\"line\">    tree.add(<span class=\"string\">&quot;D&quot;</span>)</span><br><span class=\"line\">    tree.add(<span class=\"string\">&quot;E&quot;</span>)</span><br><span class=\"line\">    tree.add(<span class=\"string\">&quot;F&quot;</span>)</span><br><span class=\"line\">    tree.add(<span class=\"string\">&quot;G&quot;</span>)</span><br><span class=\"line\">    tree.add(<span class=\"string\">&quot;H&quot;</span>)</span><br><span class=\"line\">    tree.add(<span class=\"string\">&quot;I&quot;</span>)</span><br><span class=\"line\">    tree.breadh_travel()</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>二叉树深度优先遍历</p>\n</li>\n</ul>\n</li>\n</ul>\n<center><img src=\"https://img-blog.csdnimg.cn/20210414114607443.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzIyODg3,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\" style=\"zoom: 67%;\"></center>\n<ul>\n<li>\n<p>广度优先可以找到最短路径</p>\n</li>\n<li>\n<p>深度优先往往可以很快找到搜索路径</p>\n</li>\n</ul>\n<center><img src=\"https://img-blog.csdnimg.cn/20210414114635319.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzIyODg3,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\" style=\"zoom: 67%;\"></center>\n<center><img src=\"https://img-blog.csdnimg.cn/20210414114645939.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzIyODg3,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\" style=\"zoom:67%;\"></center>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>(<span class=\"params\"><span class=\"built_in\">object</span></span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;节点类&quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span>  <span class=\"title\">__init__</span>(<span class=\"params\">self, item</span>):</span></span><br><span class=\"line\">        self.item = item</span><br><span class=\"line\">        self.lchild = <span class=\"literal\">None</span></span><br><span class=\"line\">        self.rchild = <span class=\"literal\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BinaryTree</span>(<span class=\"params\"><span class=\"built_in\">object</span></span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;完全二叉树&quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, node=<span class=\"literal\">None</span></span>):</span></span><br><span class=\"line\">        self.root = node</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add</span>(<span class=\"params\">self, item</span>):</span></span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;添加节点&quot;&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.root == <span class=\"literal\">None</span>:</span><br><span class=\"line\">            self.root = Node(item)</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 队列</span></span><br><span class=\"line\">        queue = []</span><br><span class=\"line\">        <span class=\"comment\"># 从尾部添加数据</span></span><br><span class=\"line\">        queue.append(self.root)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">            <span class=\"comment\"># 从头部取出数据</span></span><br><span class=\"line\">            node = queue.pop(<span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"comment\"># 判断左节点是否为空</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> node.lchild == <span class=\"literal\">None</span>:</span><br><span class=\"line\">                node.lchild = Node(item)</span><br><span class=\"line\">                <span class=\"keyword\">return</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                queue.append(node.lchild)</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> node.rchild == <span class=\"literal\">None</span>:</span><br><span class=\"line\">                node.rchild = Node(item)</span><br><span class=\"line\">                <span class=\"keyword\">return</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                queue.append(node.rchild)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">breadh_travel</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;广度优先遍历&quot;&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.root == <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 队列</span></span><br><span class=\"line\">        queue = []</span><br><span class=\"line\">        <span class=\"comment\"># 添加数据</span></span><br><span class=\"line\">        queue.append(self.root)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> <span class=\"built_in\">len</span>(queue)&gt;<span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"comment\"># 取出数据</span></span><br><span class=\"line\">            node = queue.pop(<span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(node.item, end=<span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\"># 判断左右子节点是否为空</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> node.lchild <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">                queue.append(node.lchild)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> node.rchild <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">                queue.append(node.rchild)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 给一个节点 就可以对这个节点以及这个节点一下的节点进行先序遍历</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">preorder_travel</span>(<span class=\"params\">self, root</span>):</span></span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;先序遍历 根 左 右&quot;&quot;&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> root <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(root.item, end=<span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">            <span class=\"comment\"># 需要对1和1以下的节点先序遍历</span></span><br><span class=\"line\">            self.preorder_travel(root.lchild)</span><br><span class=\"line\">            self.preorder_travel(root.rchild)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 给一个节点 就可以对这个节点以及这个节点一下的节点进行中序遍历</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">inorder_travel</span>(<span class=\"params\">self, root</span>):</span></span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;中序遍历 左 根 右&quot;&quot;&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> root <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            self.inorder_travel(root.lchild)</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(root.item, end=<span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">            self.inorder_travel(root.rchild)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 给一个节点 就可以对这个节点以及这个节点一下的节点进行后序遍历</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">postorder_travel</span>(<span class=\"params\">self, root</span>):</span></span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;后序遍历 根 左 右&quot;&quot;&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> root <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            self.postorder_travel(root.lchild)</span><br><span class=\"line\">            self.postorder_travel(root.rchild)</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(root.item, end=<span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    tree = BinaryTree()</span><br><span class=\"line\">    tree.add(<span class=\"string\">&quot;0&quot;</span>)</span><br><span class=\"line\">    tree.add(<span class=\"string\">&quot;1&quot;</span>)</span><br><span class=\"line\">    tree.add(<span class=\"string\">&quot;2&quot;</span>)</span><br><span class=\"line\">    tree.add(<span class=\"string\">&quot;3&quot;</span>)</span><br><span class=\"line\">    tree.add(<span class=\"string\">&quot;4&quot;</span>)</span><br><span class=\"line\">    tree.add(<span class=\"string\">&quot;5&quot;</span>)</span><br><span class=\"line\">    tree.add(<span class=\"string\">&quot;6&quot;</span>)</span><br><span class=\"line\">    tree.add(<span class=\"string\">&quot;7&quot;</span>)</span><br><span class=\"line\">    tree.add(<span class=\"string\">&quot;8&quot;</span>)</span><br><span class=\"line\">    tree.add(<span class=\"string\">&quot;9&quot;</span>)</span><br><span class=\"line\">    tree.preorder_travel(tree.root)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>()</span><br><span class=\"line\">    tree.inorder_travel(tree.root)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>()</span><br><span class=\"line\">    tree.postorder_travel(tree.root)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<p>根据遍历结果反推二叉树</p>\n</li>\n<li>\n<p>知道 <code>中序遍历</code>  和  <code>先序遍历 或者 后序遍历</code>  就可以推出二叉树的结构</p>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/20210414114743579.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzIyODg3,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n",
            "tags": [
                "人工智能",
                "数据结构与算法"
            ]
        }
    ]
}
{
    "version": "https://jsonfeed.org/version/1",
    "title": "且听风吟，御剑于心！ • All posts by \"iou\" tag",
    "description": "",
    "home_page_url": "https://leezhao415.github.io",
    "items": [
        {
            "id": "https://leezhao415.github.io/2021/08/28/%E3%80%90%E8%AF%A6%E8%A7%A3%E3%80%91IoU%E3%80%81GIoU%E3%80%81DIoU%E3%80%81CIoU%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/",
            "url": "https://leezhao415.github.io/2021/08/28/%E3%80%90%E8%AF%A6%E8%A7%A3%E3%80%91IoU%E3%80%81GIoU%E3%80%81DIoU%E3%80%81CIoU%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/",
            "title": "【详解】IoU、GIoU、DIoU、CIoU损失函数",
            "date_published": "2021-08-28T08:45:30.000Z",
            "content_html": "<meta name=\"referrer\" content=\"no-referrer\">\n<hr>\n<p><strong>文章目录</strong></p>\n<!-- toc -->\n<ul>\n<li><a href=\"#%E4%B8%80-iouintersection-over-union\">一、IOU (Intersection over Union)</a></li>\n<li><a href=\"#%E4%BA%8C-giougeneralized-intersection-over-union\">二、GIOU (Generalized Intersection over Union)</a></li>\n<li><a href=\"#%E4%B8%89-dioudistance-iou\">三、DIoU (Distance-IoU)</a></li>\n<li><a href=\"#%E5%9B%9B-cioucomplete-iou\">四、CIoU (<strong>Complete-IoU</strong>)</a></li>\n<li><a href=\"#%E4%BA%94-%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E5%9C%A8yolov3%E4%B8%8A%E7%9A%84%E6%80%A7%E8%83%BD%E8%AE%BA%E6%96%87%E6%95%88%E6%9E%9C\">五、损失函数在 YOLOv3 上的性能 (论文效果)</a></li>\n</ul>\n<!-- tocstop -->\n<hr>\n<h3><span id=\"一-iou-intersection-over-union\"> 一、IOU (Intersection over Union)</span></h3>\n<p><strong>1. 特性 (优点)</strong></p>\n<p>IoU 就是我们所说的<strong>交并比</strong>，是目标检测中最常用的指标，在<a href=\"https://zhuanlan.zhihu.com/p/62372897\"> anchor-based 的方法</a>中，他的作用不仅用来确定正样本和负样本，还可以用来评价输出框（predict box）和 ground-truth 的距离。</p>\n<center><img src=\"https://www.zhihu.com/equation?tex=IoU+%3D+%5Cfrac%7B%5Cleft%7C+A%5Ccap+B+%5Cright%7C%7D%7B%5Cleft%7C+A%5Ccup+B+%5Cright%7C%7D\" alt=\"[公式]\" style=\"zoom:90%;\"></center>\n<ol>\n<li>可以说<strong>它可以反映预测检测框与真实检测框的检测效果。</strong></li>\n<li>还有一个很好的特性就是<strong>尺度不变性</strong>，也就是对尺度不敏感（scale invariant）， 在 regression 任务中，判断 predict box 和 gt 的距离最直接的指标就是 IoU。<strong>(满足非负性；同一性；对称性；三角不等性)</strong></li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">Iou</span>(<span class=\"params\">box1, box2, wh=<span class=\"literal\">False</span></span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> wh == <span class=\"literal\">False</span>:</span><br><span class=\"line\">\txmin1, ymin1, xmax1, ymax1 = box1</span><br><span class=\"line\">\txmin2, ymin2, xmax2, ymax2 = box2</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">\txmin1, ymin1 = <span class=\"built_in\">int</span>(box1[<span class=\"number\">0</span>]-box1[<span class=\"number\">2</span>]/<span class=\"number\">2.0</span>), <span class=\"built_in\">int</span>(box1[<span class=\"number\">1</span>]-box1[<span class=\"number\">3</span>]/<span class=\"number\">2.0</span>)</span><br><span class=\"line\">\txmax1, ymax1 = <span class=\"built_in\">int</span>(box1[<span class=\"number\">0</span>]+box1[<span class=\"number\">2</span>]/<span class=\"number\">2.0</span>), <span class=\"built_in\">int</span>(box1[<span class=\"number\">1</span>]+box1[<span class=\"number\">3</span>]/<span class=\"number\">2.0</span>)</span><br><span class=\"line\">\txmin2, ymin2 = <span class=\"built_in\">int</span>(box2[<span class=\"number\">0</span>]-box2[<span class=\"number\">2</span>]/<span class=\"number\">2.0</span>), <span class=\"built_in\">int</span>(box2[<span class=\"number\">1</span>]-box2[<span class=\"number\">3</span>]/<span class=\"number\">2.0</span>)</span><br><span class=\"line\">\txmax2, ymax2 = <span class=\"built_in\">int</span>(box2[<span class=\"number\">0</span>]+box2[<span class=\"number\">2</span>]/<span class=\"number\">2.0</span>), <span class=\"built_in\">int</span>(box2[<span class=\"number\">1</span>]+box2[<span class=\"number\">3</span>]/<span class=\"number\">2.0</span>)</span><br><span class=\"line\">    <span class=\"comment\"># 获取矩形框交集对应的左上角和右下角的坐标（intersection）</span></span><br><span class=\"line\">    xx1 = np.<span class=\"built_in\">max</span>([xmin1, xmin2])</span><br><span class=\"line\">    yy1 = np.<span class=\"built_in\">max</span>([ymin1, ymin2])</span><br><span class=\"line\">    xx2 = np.<span class=\"built_in\">min</span>([xmax1, xmax2])</span><br><span class=\"line\">    yy2 = np.<span class=\"built_in\">min</span>([ymax1, ymax2])\t</span><br><span class=\"line\">    <span class=\"comment\"># 计算两个矩形框面积</span></span><br><span class=\"line\">    area1 = (xmax1-xmin1) * (ymax1-ymin1) </span><br><span class=\"line\">    area2 = (xmax2-xmin2) * (ymax2-ymin2)</span><br><span class=\"line\">    inter_area = (np.<span class=\"built_in\">max</span>([<span class=\"number\">0</span>, xx2-xx1])) * (np.<span class=\"built_in\">max</span>([<span class=\"number\">0</span>, yy2-yy1]))　<span class=\"comment\">#计算交集面积</span></span><br><span class=\"line\">    iou = inter_area / (area1+area2-inter_area+<span class=\"number\">1e-6</span>) 　<span class=\"comment\">#计算交并比</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> iou</span><br></pre></td></tr></table></figure>\n<p><strong>2. 作为损失函数会出现的问题 (缺点)</strong></p>\n<ol>\n<li>如果两个框没有相交，根据定义，IoU=0，不能反映两者的距离大小（重合度）。同时因为 loss=0，没有梯度回传，无法进行学习训练。</li>\n<li>IoU 无法精确的反映两者的重合度大小。如下图所示，三种情况 IoU 都相等，但看得出来他们的重合度是不一样的，左边的图回归的效果最好，右边的最差。</li>\n</ol>\n<center><img src=\"https://pic2.zhimg.com/80/v2-95449558cb098ff9df8c4d31474bd091_1440w.jpg\" alt=\"img\" style=\"zoom:90%;\"></center>\n<h3><span id=\"二-giou-generalized-intersection-over-union\"> 二、GIOU (Generalized Intersection over Union)</span></h3>\n<p><strong>1、来源</strong></p>\n<p>在 CVPR2019 中，论文</p>\n<p><a href=\"https://link.zhihu.com/?target=https%3A//arxiv.org/abs/1902.09630\">《Generalized Intersection over Union: A Metric and A Loss for Bounding Box Regression》arxiv.org/abs/1902.09630</a></p>\n<p>的提出了 GIoU 的思想。由于 IoU 是<strong>比值</strong>的概念，对目标物体的 scale 是不敏感的。然而检测任务中的 BBox 的回归损失 (MSE loss, l1-smooth loss 等）优化和 IoU 优化不是完全等价的，而且 Ln 范数对物体的 scale 也比较敏感，IoU 无法直接优化没有重叠的部分。</p>\n<p>这篇论文提出可以直接把 IoU 设为回归的 loss。</p>\n<center><img src=\"https://www.zhihu.com/equation?tex=GIoU+%3D+IoU+-+%5Cfrac%7B%5Cleft%7C++A_%7Bc%7D+-+U+%5Cright%7C%7D%7B%5Cleft%7C+A_%7Bc%7D+%5Cright%7C%7D\" alt=\"[公式]\" style=\"zoom:80%;\"></center>\n<center><img src=\"C:\\Users\\14767\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210828164108323.png\" alt=\"image-20210828164108323\" style=\"zoom:80%;\"></center>\n<ul>\n<li>GIoU 对 scale 不敏感</li>\n<li>GIoU 是 IoU 的下界，在两个框无限重合的情况下，IoU=GIoU=1</li>\n<li>IoU 取值 [0,1]，但 GIoU 有对称区间，取值范围 [-1,1]。在两者重合的时候取最大值 1，在两者无交集且无限远的时候取最小值 - 1，因此 GIoU 是一个非常好的距离度量指标。</li>\n<li>与 IoU 只关注重叠区域不同，<strong>GIoU 不仅关注重叠区域，还关注其他的非重合区域</strong>，能更好的反映两者的重合度。</li>\n</ul>\n<center><img src=\"https://pic3.zhimg.com/80/v2-71e809433f6b26fcf30b4aeb6578413a_1440w.jpg\" alt=\"img\" style=\"zoom: 33%;\"></center>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">Giou</span>(<span class=\"params\">rec1,rec2</span>):</span></span><br><span class=\"line\">    <span class=\"comment\">#分别是第一个矩形左右上下的坐标</span></span><br><span class=\"line\">    x1,x2,y1,y2 = rec1 </span><br><span class=\"line\">    x3,x4,y3,y4 = rec2</span><br><span class=\"line\">    iou = Iou(rec1,rec2)</span><br><span class=\"line\">    area_C = (<span class=\"built_in\">max</span>(x1,x2,x3,x4)-<span class=\"built_in\">min</span>(x1,x2,x3,x4))*(<span class=\"built_in\">max</span>(y1,y2,y3,y4)-<span class=\"built_in\">min</span>(y1,y2,y3,y4))</span><br><span class=\"line\">    area_1 = (x2-x1)*(y1-y2)</span><br><span class=\"line\">    area_2 = (x4-x3)*(y3-y4)</span><br><span class=\"line\">    sum_area = area_1 + area_2</span><br><span class=\"line\"></span><br><span class=\"line\">    w1 = x2 - x1   <span class=\"comment\">#第一个矩形的宽</span></span><br><span class=\"line\">    w2 = x4 - x3   <span class=\"comment\">#第二个矩形的宽</span></span><br><span class=\"line\">    h1 = y1 - y2</span><br><span class=\"line\">    h2 = y3 - y4</span><br><span class=\"line\">    W = <span class=\"built_in\">min</span>(x1,x2,x3,x4)+w1+w2-<span class=\"built_in\">max</span>(x1,x2,x3,x4)    <span class=\"comment\">#交叉部分的宽</span></span><br><span class=\"line\">    H = <span class=\"built_in\">min</span>(y1,y2,y3,y4)+h1+h2-<span class=\"built_in\">max</span>(y1,y2,y3,y4)    <span class=\"comment\">#交叉部分的高</span></span><br><span class=\"line\">    Area = W*H    <span class=\"comment\">#交叉的面积</span></span><br><span class=\"line\">    add_area = sum_area - Area    <span class=\"comment\">#两矩形并集的面积</span></span><br><span class=\"line\"></span><br><span class=\"line\">    end_area = (area_C - add_area)/area_C    <span class=\"comment\">#闭包区域中不属于两个框的区域占闭包区域的比重</span></span><br><span class=\"line\">    giou = iou - end_area</span><br><span class=\"line\">    <span class=\"keyword\">return</span> giou</span><br></pre></td></tr></table></figure>\n<h3><span id=\"三-diou-distance-iou\"> 三、DIoU (Distance-IoU)</span></h3>\n<p><strong>1、来源</strong></p>\n<p>DIoU 要比 GIou 更加符合目标框回归的机制，<strong>将目标与 anchor 之间的距离，重叠率以及尺度都考虑进去</strong>，使得目标框回归变得更加稳定，不会像 IoU 和 GIoU 一样出现训练过程中发散等问题。论文中</p>\n<p><a href=\"https://link.zhihu.com/?target=https%3A//arxiv.org/pdf/1911.08287.pdf\">Distance-IoUarxiv.org/pdf/1911.08287.pdf</a></p>\n<blockquote>\n<p>基于 IoU 和 GIoU 存在的问题，作者提出了两个问题：</p>\n<p>1. 直接最小化 anchor 框与目标框之间的归一化距离是否可行，以达到更快的收敛速度？</p>\n<p>2. 如何使回归在与目标框有重叠甚至包含时更准确、更快？</p>\n</blockquote>\n<center><img src=\"https://www.zhihu.com/equation?tex=DIoU+%3D+IoU+-+%5Cfrac%7B%5Crho%5E%7B2%7D%28b%2Cb%5E%7Bgt%7D%29%7D%7Bc%5E%7B2%7D%7D\" alt=\"[公式]\" style=\"zoom:90%;\"></center>\n<p>其中，b, b<sup>gt</sup> 分别代表了预测框和真实框的中心点，且<em> ρ</em> 代表的是计算两个中心点间的欧式距离。 <em>c</em> 代表的是能够同时包含预测框和真实框的<strong>最小闭包区域</strong>的对角线距离。</p>\n<center><img src=\"https://pic3.zhimg.com/80/v2-1e4b54001c4abdf392fe9d4877c83972_1440w.jpg\" alt=\"img\" style=\"zoom:80%;\"></center>\n<p>DIoU 中对 anchor 框和目标框之间的归一化距离进行了建模</p>\n<p>附：</p>\n<p>YOLOV3 DIoU GitHub 项目地址：<a href=\"https://link.zhihu.com/?target=https%3A//github.com/Zzh-tju/DIoU-darknet\">github.com/Zzh-tju/DIoU-darknet</a></p>\n<p><strong>2、优点</strong></p>\n<center><img src=\"C:\\Users\\14767\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210828163809043.png\" alt=\"image-20210828163809043\" style=\"zoom:80%;\"></center>\n<ul>\n<li>DIoU loss 可以直接最小化两个目标框的距离，因此比 GIoU loss 收敛快得多。</li>\n<li>对于包含两个框在水平方向和垂直方向上这种情况，DIoU 损失可以使回归非常快，而 GIoU 损失几乎退化为 IoU 损失。</li>\n<li>DIoU 还可以替换普通的 IoU 评价策略，应用于 NMS 中，使得 NMS 得到的结果更加合理和有效。</li>\n</ul>\n<p>实现代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">Diou</span>(<span class=\"params\">bboxes1, bboxes2</span>):</span></span><br><span class=\"line\">    rows = bboxes1.shape[<span class=\"number\">0</span>]</span><br><span class=\"line\">    cols = bboxes2.shape[<span class=\"number\">0</span>]</span><br><span class=\"line\">    dious = torch.zeros((rows, cols))</span><br><span class=\"line\">    <span class=\"keyword\">if</span> rows * cols == <span class=\"number\">0</span>:<span class=\"comment\">#</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> dious</span><br><span class=\"line\">    exchange = <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> bboxes1.shape[<span class=\"number\">0</span>] &gt; bboxes2.shape[<span class=\"number\">0</span>]:</span><br><span class=\"line\">        bboxes1, bboxes2 = bboxes2, bboxes1</span><br><span class=\"line\">        dious = torch.zeros((cols, rows))</span><br><span class=\"line\">        exchange = <span class=\"literal\">True</span></span><br><span class=\"line\">    <span class=\"comment\"># #xmin,ymin,xmax,ymax-&gt;[:,0],[:,1],[:,2],[:,3]</span></span><br><span class=\"line\">    w1 = bboxes1[:, <span class=\"number\">2</span>] - bboxes1[:, <span class=\"number\">0</span>]</span><br><span class=\"line\">    h1 = bboxes1[:, <span class=\"number\">3</span>] - bboxes1[:, <span class=\"number\">1</span>] </span><br><span class=\"line\">    w2 = bboxes2[:, <span class=\"number\">2</span>] - bboxes2[:, <span class=\"number\">0</span>]</span><br><span class=\"line\">    h2 = bboxes2[:, <span class=\"number\">3</span>] - bboxes2[:, <span class=\"number\">1</span>]</span><br><span class=\"line\">    </span><br><span class=\"line\">    area1 = w1 * h1</span><br><span class=\"line\">    area2 = w2 * h2</span><br><span class=\"line\"></span><br><span class=\"line\">    center_x1 = (bboxes1[:, <span class=\"number\">2</span>] + bboxes1[:, <span class=\"number\">0</span>]) / <span class=\"number\">2</span> </span><br><span class=\"line\">    center_y1 = (bboxes1[:, <span class=\"number\">3</span>] + bboxes1[:, <span class=\"number\">1</span>]) / <span class=\"number\">2</span> </span><br><span class=\"line\">    center_x2 = (bboxes2[:, <span class=\"number\">2</span>] + bboxes2[:, <span class=\"number\">0</span>]) / <span class=\"number\">2</span></span><br><span class=\"line\">    center_y2 = (bboxes2[:, <span class=\"number\">3</span>] + bboxes2[:, <span class=\"number\">1</span>]) / <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">    inter_max_xy = torch.<span class=\"built_in\">min</span>(bboxes1[:, <span class=\"number\">2</span>:],bboxes2[:, <span class=\"number\">2</span>:]) </span><br><span class=\"line\">    inter_min_xy = torch.<span class=\"built_in\">max</span>(bboxes1[:, :<span class=\"number\">2</span>],bboxes2[:, :<span class=\"number\">2</span>]) </span><br><span class=\"line\">    out_max_xy = torch.<span class=\"built_in\">max</span>(bboxes1[:, <span class=\"number\">2</span>:],bboxes2[:, <span class=\"number\">2</span>:]) </span><br><span class=\"line\">    out_min_xy = torch.<span class=\"built_in\">min</span>(bboxes1[:, :<span class=\"number\">2</span>],bboxes2[:, :<span class=\"number\">2</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">    inter = torch.clamp((inter_max_xy - inter_min_xy), <span class=\"built_in\">min</span>=<span class=\"number\">0</span>)</span><br><span class=\"line\">    inter_area = inter[:, <span class=\"number\">0</span>] * inter[:, <span class=\"number\">1</span>]</span><br><span class=\"line\">    inter_diag = (center_x2 - center_x1)**<span class=\"number\">2</span> + (center_y2 - center_y1)**<span class=\"number\">2</span></span><br><span class=\"line\">    outer = torch.clamp((out_max_xy - out_min_xy), <span class=\"built_in\">min</span>=<span class=\"number\">0</span>)</span><br><span class=\"line\">    outer_diag = (outer[:, <span class=\"number\">0</span>] ** <span class=\"number\">2</span>) + (outer[:, <span class=\"number\">1</span>] ** <span class=\"number\">2</span>)</span><br><span class=\"line\">    union = area1+area2-inter_area</span><br><span class=\"line\">    dious = inter_area / union - (inter_diag) / outer_diag</span><br><span class=\"line\">    dious = torch.clamp(dious,<span class=\"built_in\">min</span>=-<span class=\"number\">1.0</span>,<span class=\"built_in\">max</span> = <span class=\"number\">1.0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> exchange:</span><br><span class=\"line\">        dious = dious.T</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dious</span><br></pre></td></tr></table></figure>\n<h3><span id=\"四-ciou-complete-iou\"> 四、CIoU (<strong>Complete-IoU</strong>)</span></h3>\n<center><img src=\"C:\\Users\\14767\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210828163615875.png\" alt=\"image-20210828163615875\" style=\"zoom:80%;\"></center>\n<p>实现代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">bbox_overlaps_ciou</span>(<span class=\"params\">bboxes1, bboxes2</span>):</span></span><br><span class=\"line\">    rows = bboxes1.shape[<span class=\"number\">0</span>]</span><br><span class=\"line\">    cols = bboxes2.shape[<span class=\"number\">0</span>]</span><br><span class=\"line\">    cious = torch.zeros((rows, cols))</span><br><span class=\"line\">    <span class=\"keyword\">if</span> rows * cols == <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cious</span><br><span class=\"line\">    exchange = <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> bboxes1.shape[<span class=\"number\">0</span>] &gt; bboxes2.shape[<span class=\"number\">0</span>]:</span><br><span class=\"line\">        bboxes1, bboxes2 = bboxes2, bboxes1</span><br><span class=\"line\">        cious = torch.zeros((cols, rows))</span><br><span class=\"line\">        exchange = <span class=\"literal\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\">    w1 = bboxes1[:, <span class=\"number\">2</span>] - bboxes1[:, <span class=\"number\">0</span>]</span><br><span class=\"line\">    h1 = bboxes1[:, <span class=\"number\">3</span>] - bboxes1[:, <span class=\"number\">1</span>]</span><br><span class=\"line\">    w2 = bboxes2[:, <span class=\"number\">2</span>] - bboxes2[:, <span class=\"number\">0</span>]</span><br><span class=\"line\">    h2 = bboxes2[:, <span class=\"number\">3</span>] - bboxes2[:, <span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    area1 = w1 * h1</span><br><span class=\"line\">    area2 = w2 * h2</span><br><span class=\"line\"></span><br><span class=\"line\">    center_x1 = (bboxes1[:, <span class=\"number\">2</span>] + bboxes1[:, <span class=\"number\">0</span>]) / <span class=\"number\">2</span></span><br><span class=\"line\">    center_y1 = (bboxes1[:, <span class=\"number\">3</span>] + bboxes1[:, <span class=\"number\">1</span>]) / <span class=\"number\">2</span></span><br><span class=\"line\">    center_x2 = (bboxes2[:, <span class=\"number\">2</span>] + bboxes2[:, <span class=\"number\">0</span>]) / <span class=\"number\">2</span></span><br><span class=\"line\">    center_y2 = (bboxes2[:, <span class=\"number\">3</span>] + bboxes2[:, <span class=\"number\">1</span>]) / <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">    inter_max_xy = torch.<span class=\"built_in\">min</span>(bboxes1[:, <span class=\"number\">2</span>:],bboxes2[:, <span class=\"number\">2</span>:])</span><br><span class=\"line\">    inter_min_xy = torch.<span class=\"built_in\">max</span>(bboxes1[:, :<span class=\"number\">2</span>],bboxes2[:, :<span class=\"number\">2</span>])</span><br><span class=\"line\">    out_max_xy = torch.<span class=\"built_in\">max</span>(bboxes1[:, <span class=\"number\">2</span>:],bboxes2[:, <span class=\"number\">2</span>:])</span><br><span class=\"line\">    out_min_xy = torch.<span class=\"built_in\">min</span>(bboxes1[:, :<span class=\"number\">2</span>],bboxes2[:, :<span class=\"number\">2</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">    inter = torch.clamp((inter_max_xy - inter_min_xy), <span class=\"built_in\">min</span>=<span class=\"number\">0</span>)</span><br><span class=\"line\">    inter_area = inter[:, <span class=\"number\">0</span>] * inter[:, <span class=\"number\">1</span>]</span><br><span class=\"line\">    inter_diag = (center_x2 - center_x1)**<span class=\"number\">2</span> + (center_y2 - center_y1)**<span class=\"number\">2</span></span><br><span class=\"line\">    outer = torch.clamp((out_max_xy - out_min_xy), <span class=\"built_in\">min</span>=<span class=\"number\">0</span>)</span><br><span class=\"line\">    outer_diag = (outer[:, <span class=\"number\">0</span>] ** <span class=\"number\">2</span>) + (outer[:, <span class=\"number\">1</span>] ** <span class=\"number\">2</span>)</span><br><span class=\"line\">    union = area1+area2-inter_area</span><br><span class=\"line\">    u = (inter_diag) / outer_diag</span><br><span class=\"line\">    iou = inter_area / union</span><br><span class=\"line\">    <span class=\"keyword\">with</span> torch.no_grad():</span><br><span class=\"line\">        arctan = torch.atan(w2 / h2) - torch.atan(w1 / h1)</span><br><span class=\"line\">        v = (<span class=\"number\">4</span> / (math.pi ** <span class=\"number\">2</span>)) * torch.<span class=\"built_in\">pow</span>((torch.atan(w2 / h2) - torch.atan(w1 / h1)), <span class=\"number\">2</span>)</span><br><span class=\"line\">        S = <span class=\"number\">1</span> - iou</span><br><span class=\"line\">        alpha = v / (S + v)</span><br><span class=\"line\">        w_temp = <span class=\"number\">2</span> * w1</span><br><span class=\"line\">    ar = (<span class=\"number\">8</span> / (math.pi ** <span class=\"number\">2</span>)) * arctan * ((w1 - w_temp) * h1)</span><br><span class=\"line\">    cious = iou - (u + alpha * ar)</span><br><span class=\"line\">    cious = torch.clamp(cious,<span class=\"built_in\">min</span>=-<span class=\"number\">1.0</span>,<span class=\"built_in\">max</span> = <span class=\"number\">1.0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> exchange:</span><br><span class=\"line\">        cious = cious.T</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cious</span><br></pre></td></tr></table></figure>\n<h3><span id=\"五-损失函数在-yolov3-上的性能-论文效果\"> 五、损失函数在 YOLOv3 上的性能 (论文效果)</span></h3>\n<center><img src=\"https://pic2.zhimg.com/80/v2-9d958cbbf6b13cddceeeb296c2f9a735_1440w.jpg\" alt=\"img\" style=\"zoom: 33%;\"></center>\n<p>目标检测算法之 AAAI 2020 DIoU Loss 已开源 (YOLOV3 涨近 3 个点)：<a href=\"https://link.zhihu.com/?target=https%3A//cloud.tencent.com/developer/article/1558533\">cloud.tencent.com/developer/article/1558533</a></p>\n",
            "tags": [
                "人工智能",
                "IOU"
            ]
        }
    ]
}